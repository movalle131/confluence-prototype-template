/* panel-splitter.tsx generated by @compiled/babel-plugin v0.36.1 */
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
var _typeof = require("@babel/runtime/helpers/typeof");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.PanelSplitter = void 0;
exports.isPanelSplitterDragData = isPanelSplitterDragData;
require("./panel-splitter.compiled.css");
var _react = _interopRequireWildcard(require("react"));
var React = _react;
var _runtime = require("@compiled/react/runtime");
var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
var _bindEventListener = require("bind-event-listener");
var _reactDom = require("react-dom");
var _tinyInvariant = _interopRequireDefault(require("tiny-invariant"));
var _useId = require("@atlaskit/ds-lib/use-id");
var _useStableRef = _interopRequireDefault(require("@atlaskit/ds-lib/use-stable-ref"));
var _openLayerObserver = require("@atlaskit/layering/experimental/open-layer-observer");
var _combine = require("@atlaskit/pragmatic-drag-and-drop/combine");
var _adapter = require("@atlaskit/pragmatic-drag-and-drop/element/adapter");
var _blockDraggingToIframes = require("@atlaskit/pragmatic-drag-and-drop/element/block-dragging-to-iframes");
var _disableNativeDragPreview = require("@atlaskit/pragmatic-drag-and-drop/element/disable-native-drag-preview");
var _preventUnhandled = require("@atlaskit/pragmatic-drag-and-drop/prevent-unhandled");
var _visuallyHidden = _interopRequireDefault(require("@atlaskit/visually-hidden"));
var _context = require("./context");
var _convertResizeBoundToPixels = require("./convert-resize-bound-to-pixels");
var _getPercentageWithinPixelBounds = require("./get-percentage-within-pixel-bounds");
var _getWidth = require("./get-width");
var _keyboardResizeManager = require("./keyboard-resize-manager");
function _interopRequireWildcard(e, t) { if ("function" == typeof WeakMap) var r = new WeakMap(), n = new WeakMap(); return (_interopRequireWildcard = function _interopRequireWildcard(e, t) { if (!t && e && e.__esModule) return e; var o, i, f = { __proto__: null, default: e }; if (null === e || "object" != _typeof(e) && "function" != typeof e) return f; if (o = t ? n : r) { if (o.has(e)) return o.get(e); o.set(e, f); } for (var _t in e) "default" !== _t && {}.hasOwnProperty.call(e, _t) && ((i = (o = Object.defineProperty) && Object.getOwnPropertyDescriptor(e, _t)) && (i.get || i.set) ? o(f, _t, i) : f[_t] = e[_t]); return f; })(e, t); }
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { (0, _defineProperty2.default)(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
var containerStyles = {
  root: "_12ji1r31 _1qu2glyw _12y31o36 _1e0cglyw _kqswstnw _u7coidpf _152tidpf _1pbykb7n _181n1ule",
  positionEnd: "_rjxpftgi",
  positionStart: "_1e02zeo2"
};
var grabAreaStyles = {
  root: "_1bsbl52n _4t3i1osq _kqswstnw _ca0qze3t _u5f3ze3t _n3tdze3t _19bvze3t _syaz1j28 _bfhk1j28 _k8m01ylx _1oec1yx9 _1lww5cps _d0aluf7j _1gavfnf5 _vp7gaqb7 _30l3aqb7 _1dr21ylx _1s5z1ylx _1cg4fnf5 _le1bfnf5 _1gglglyw _9h8h16c2"
};
var lineStyles = {
  root: "_kqswstnw _1e0c1ule _1bsbjfq9 _4t3i1osq _syaz1kw7 _bfhk1r31 _1e021v6z"
};
var panelSplitterDragDataSymbol = Symbol('panel-splitter-drag-data');
function signPanelSplitterDragData(data) {
  return _objectSpread(_objectSpread({}, data), {}, (0, _defineProperty2.default)({}, panelSplitterDragDataSymbol, true));
}
function isPanelSplitterDragData(data) {
  return data[panelSplitterDragDataSymbol] === true;
}
function getTextDirection(element) {
  var _window$getComputedSt = window.getComputedStyle(element),
    direction = _window$getComputedSt.direction;
  return direction === 'rtl' ? 'rtl' : 'ltr';
}
var PortaledPanelSplitter = function PortaledPanelSplitter(_ref) {
  var label = _ref.label,
    onResizeStart = _ref.onResizeStart,
    onResizeEnd = _ref.onResizeEnd,
    testId = _ref.testId,
    panelId = _ref.panelId,
    panelWidth = _ref.panelWidth,
    onCompleteResize = _ref.onCompleteResize,
    getResizeBounds = _ref.getResizeBounds,
    panel = _ref.panel,
    portal = _ref.portal,
    resizingCssVar = _ref.resizingCssVar,
    position = _ref.position;
  var splitterRef = (0, _react.useRef)(null);
  var labelId = (0, _useId.useId)();
  // Separate state used for the input range width to remove the UI's dependency on the "persisted" layout state value being updated
  var _useState = (0, _react.useState)(panelWidth),
    _useState2 = (0, _slicedToArray2.default)(_useState, 2),
    rangeInputValue = _useState2[0],
    setRangeInputValue = _useState2[1];

  /**
   * We are using state to store the resize bounds _converted into pixel units_, so that we can update them when the window is resized.
   * Otherwise they can become out of sync with the actual viewport size, and cause a broken experience (inaccurate width percentage)
   * when the user tries to resize using the keyboard.
   */
  var _useState3 = (0, _react.useState)({
      // Using placeholder values here for the initial render. These will be calculated and updated when the range input is focused.
      min: 200,
      max: 500
    }),
    _useState4 = (0, _slicedToArray2.default)(_useState3, 2),
    rangeInputBounds = _useState4[0],
    setRangeInputBounds = _useState4[1];
  var openLayerObserver = (0, _openLayerObserver.useOpenLayerObserver)();
  (0, _react.useEffect)(function () {
    var splitter = splitterRef.current;
    (0, _tinyInvariant.default)(splitter, 'Splitter ref must be set');
    return (0, _combine.combine)((0, _blockDraggingToIframes.blockDraggingToIFrames)({
      element: splitter
    }), (0, _adapter.draggable)({
      element: splitter,
      onGenerateDragPreview: function onGenerateDragPreview(_ref2) {
        var nativeSetDragImage = _ref2.nativeSetDragImage;
        // We will be moving the line to indicate a drag. We can disable the native drag preview
        (0, _disableNativeDragPreview.disableNativeDragPreview)({
          nativeSetDragImage: nativeSetDragImage
        });
        // We don't want any native drop animation for when the user does not drop on a drop target. We want the drag to finish immediately
        _preventUnhandled.preventUnhandled.start();
      },
      getInitialData: function getInitialData() {
        var initialWidth = (0, _getWidth.getPixelWidth)(panel);

        /**
         * The drag calculations require the actual computed width of the element
         * For example, if the panel has loaded with a width of 2000px, but the max bound is 1000px and is visually 1000px (due to the CSS `clamp()`),
         * the drag calculations should use the actual width of 1000px, not the width in state of 2000px.
         */
        return signPanelSplitterDragData({
          panelId: panelId,
          initialWidth: initialWidth,
          resizingWidth: "".concat(initialWidth, "px"),
          resizeBounds: getResizeBounds(),
          // Only computing text direction when we need it, just as the drag is starting.
          // Recomputing text direction on each new drag in case the text direction
          // has changed. This is unlikely, but being safe.
          direction: getTextDirection(panel)
        });
      },
      onDragStart: function onDragStart(_ref3) {
        var source = _ref3.source;
        (0, _tinyInvariant.default)(isPanelSplitterDragData(source.data));
        onResizeStart === null || onResizeStart === void 0 || onResizeStart({
          initialWidth: source.data.initialWidth
        });

        // Close any open layers when the user starts resizing
        openLayerObserver === null || openLayerObserver === void 0 || openLayerObserver.closeLayers();
      },
      onDrag: function onDrag(_ref4) {
        var location = _ref4.location,
          source = _ref4.source;
        (0, _tinyInvariant.default)(isPanelSplitterDragData(source.data));
        var _source$data = source.data,
          initialWidth = _source$data.initialWidth,
          resizeBounds = _source$data.resizeBounds,
          direction = _source$data.direction;

        /**
         * How wide the element would be if there were no width constraints,
         * based on the pointer's position.
         */
        var targetWidth = (0, _getWidth.getWidthFromDragLocation)({
          initialWidth: initialWidth,
          location: location,
          direction: direction,
          position: position
        });
        var resizingWidth = "clamp(".concat(resizeBounds.min, ", ").concat(targetWidth, "px, ").concat(resizeBounds.max, ")");
        panel.style.setProperty(resizingCssVar, resizingWidth);
        source.data.resizingWidth = resizingWidth;
      },
      onDrop: function onDrop(_ref5) {
        var source = _ref5.source;
        (0, _tinyInvariant.default)(isPanelSplitterDragData(source.data));
        _preventUnhandled.preventUnhandled.stop();
        (0, _tinyInvariant.default)(isPanelSplitterDragData(source.data));
        var finalWidth = (0, _getWidth.getPixelWidth)(panel);
        onCompleteResize(finalWidth);
        onResizeEnd === null || onResizeEnd === void 0 || onResizeEnd({
          initialWidth: source.data.initialWidth,
          finalWidth: finalWidth
        });
        panel.style.removeProperty(resizingCssVar);
      }
    }));
  }, [onCompleteResize, onResizeStart, onResizeEnd, panel, resizingCssVar, panelWidth, position, openLayerObserver, panelId, getResizeBounds]);
  var onResizeStartStableRef = (0, _useStableRef.default)(onResizeStart);
  var onResizeEndStableRef = (0, _useStableRef.default)(onResizeEnd);
  var _useState5 = (0, _react.useState)(function () {
      return (0, _keyboardResizeManager.createKeyboardResizeManager)({
        onResizeStart: function onResizeStart() {
          var _onResizeStartStableR;
          // Close any open layers when the user starts resizing with keyboard
          openLayerObserver === null || openLayerObserver === void 0 || openLayerObserver.closeLayers();
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          (_onResizeStartStableR = onResizeStartStableRef.current) === null || _onResizeStartStableR === void 0 || _onResizeStartStableR.call.apply(_onResizeStartStableR, [onResizeStartStableRef].concat(args));
        },
        onResizeEnd: function onResizeEnd() {
          var _onResizeEndStableRef;
          for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
            args[_key2] = arguments[_key2];
          }
          return (_onResizeEndStableRef = onResizeEndStableRef.current) === null || _onResizeEndStableRef === void 0 ? void 0 : _onResizeEndStableRef.call.apply(_onResizeEndStableRef, [onResizeEndStableRef].concat(args));
        }
      });
    }),
    _useState6 = (0, _slicedToArray2.default)(_useState5, 1),
    keyboardResizeManager = _useState6[0];
  var handleSliderInputChange = (0, _react.useCallback)(function (event) {
    var value = parseInt(event.target.value);
    setRangeInputValue(value);

    /**
     * We are intentionally _not_ debouncing `onCompleteResize` as we want it to be called anytime the user changes the range input value.
     * It is an internal-only callback - it's provided by `PanelSplitterProvider`, and used by layout slots to update their layout width state.
     */
    onCompleteResize(value);
    keyboardResizeManager.onResize({
      initialWidth: panelWidth,
      finalWidth: value
    });
  }, [onCompleteResize, panelWidth, keyboardResizeManager]);
  var resizeEventListenerCleanupFn = (0, _react.useRef)(null);
  var handleSliderFocus = (0, _react.useCallback)(function () {
    var _resizeEventListenerC;
    /**
     * We are only updating the range input's properties when the element is focused, as a performance optimisation.
     * It isn't necessary to recalculate these values until the element is going to be used.
     */

    // Clean up any left over listeners in case `focus` was triggered again without `blur`.
    (_resizeEventListenerC = resizeEventListenerCleanupFn.current) === null || _resizeEventListenerC === void 0 || _resizeEventListenerC.call(resizeEventListenerCleanupFn);

    // Update the range input value to match the current panel width.
    setRangeInputValue(panelWidth);
    var resizeBounds = getResizeBounds();

    // Update the range input bounds to ensure they are accurate (in case the viewport was previously resized)
    setRangeInputBounds({
      min: (0, _convertResizeBoundToPixels.convertResizeBoundToPixels)(resizeBounds.min),
      max: (0, _convertResizeBoundToPixels.convertResizeBoundToPixels)(resizeBounds.max)
    });

    /**
     * _While the slider element is focused_, add a window resize event listener to update the range input bounds
     * when the window is resized. This is needed to ensure the min and max widths accurately reflect the viewport
     * size - in case they are provided in vw units.
     *
     * This listener is cleaned up when the element is blurred.
     */
    resizeEventListenerCleanupFn.current = (0, _bindEventListener.bind)(window, {
      type: 'resize',
      listener: function updateState() {
        var resizeBounds = getResizeBounds();
        setRangeInputBounds({
          min: (0, _convertResizeBoundToPixels.convertResizeBoundToPixels)(resizeBounds.min),
          max: (0, _convertResizeBoundToPixels.convertResizeBoundToPixels)(resizeBounds.max)
        });
      }
    });
  }, [panelWidth, getResizeBounds]);
  var handleSliderBlur = (0, _react.useCallback)(function () {
    var _resizeEventListenerC2;
    // Remove the resize event listener when the range input is blurred.
    (_resizeEventListenerC2 = resizeEventListenerCleanupFn.current) === null || _resizeEventListenerC2 === void 0 || _resizeEventListenerC2.call(resizeEventListenerCleanupFn);
  }, []);
  (0, _react.useEffect)(function () {
    return function cleanup() {
      var _resizeEventListenerC3;
      // Cleanup the resize event listener when the component is unmounted.
      (_resizeEventListenerC3 = resizeEventListenerCleanupFn.current) === null || _resizeEventListenerC3 === void 0 || _resizeEventListenerC3.call(resizeEventListenerCleanupFn);
    };
  }, []);
  var ariaValueText = (0, _react.useMemo)(function () {
    return "".concat((0, _getPercentageWithinPixelBounds.getPercentageWithinPixelBounds)({
      currentWidth: rangeInputValue,
      resizeBounds: rangeInputBounds
    }), "% width");
  }, [rangeInputValue, rangeInputBounds]);
  return /*#__PURE__*/(0, _reactDom.createPortal)( /*#__PURE__*/React.createElement("div", {
    "data-testid": testId ? "".concat(testId, "-container") : undefined,
    className: (0, _runtime.ax)([containerStyles.root, position === 'start' && containerStyles.positionStart, position === 'end' && containerStyles.positionEnd])
  }, /*#__PURE__*/React.createElement("div", {
    ref: splitterRef,
    "data-testid": testId,
    className: (0, _runtime.ax)([grabAreaStyles.root])
  }, /*#__PURE__*/React.createElement(_visuallyHidden.default, null, /*#__PURE__*/React.createElement("input", {
    type: "range",
    value: rangeInputValue,
    step: 20,
    min: rangeInputBounds.min,
    max: rangeInputBounds.max,
    "aria-valuetext": ariaValueText,
    "aria-labelledby": labelId,
    onChange: handleSliderInputChange,
    onFocus: handleSliderFocus,
    onBlur: handleSliderBlur
  }), /*#__PURE__*/React.createElement("span", {
    id: labelId
  }, label)), /*#__PURE__*/React.createElement("span", {
    className: (0, _runtime.ax)([lineStyles.root])
  }))), portal);
};

/**
 * _PanelSplitter_
 *
 * A component that allows the user to resize a layout area.
 * It can be used within layout areas like `SideNav`, `Panel`, and `Aside`. The layout area component should
 * provide the context for it using `<PanelSplitterProvider>`.
 *
 * Example usage in products:
 * ```tsx
 * <SideNav>
 *   {/* other side nav content *}
 *   <PanelSplitter label="Resize Side Nav" />
 * </SideNav>
 * ```
 */
var PanelSplitter = exports.PanelSplitter = function PanelSplitter(_ref6) {
  var label = _ref6.label,
    onResizeStart = _ref6.onResizeStart,
    onResizeEnd = _ref6.onResizeEnd,
    testId = _ref6.testId;
  var _useState7 = (0, _react.useState)(null),
    _useState8 = (0, _slicedToArray2.default)(_useState7, 2),
    panel = _useState8[0],
    setPanel = _useState8[1];
  var _useState9 = (0, _react.useState)(null),
    _useState0 = (0, _slicedToArray2.default)(_useState9, 2),
    portal = _useState0[0],
    setPortal = _useState0[1];
  var context = (0, _react.useContext)(_context.PanelSplitterContext);
  (0, _tinyInvariant.default)(context, 'Panel splitter context not set');
  var panelRef = context.panelRef,
    portalRef = context.portalRef,
    isEnabled = context.isEnabled,
    panelId = context.panelId,
    panelWidth = context.panelWidth,
    onCompleteResize = context.onCompleteResize,
    getResizeBounds = context.getResizeBounds,
    resizingCssVar = context.resizingCssVar,
    position = context.position;

  /**
   * **Explanation**
   *
   * _How React Suspense works_
   *
   * When a component is suspended:
   *
   * - it is _not_ "unmounted" and effects are _not_ cleaned up
   * - refs to react managed elements are cleared
   * - react adds `display:none !important` as an inline style to hide the element
   * - state is preserved
   *
   * When a suspended component is resumed:
   * - `display:none !important` inline style is removed
   * - it will re-render (without the refs set)
   * - refs will be set
   * - `useEffect` will _not_ re-run
   *
   * [More details](https://x.com/alexandereardon/status/1944617494569992440)
   *
   * _What does this mean for the panel splitter?_
   *
   * - The panel splitter renders into content into a react managed element (eg managed by Aside)
   * - When UI is suspended the portal ref is cleared
   * - After a suspense, we will get a render with cleared refs
   * - 🔥 This is problematic if we want to portal into that ref during the render
   *
   * _Approach: initial render_
   *
   * - We cannot portal the panel splitter until after the refs are initially set
   * - Effects run after refs being set. In an effect we set the ref values (which are populated),
   *   trigger a re-render and then portal into the refs.
   *
   * _Approach: suspense_
   *
   * - We put the refs into react `state` after every render
   * - The refs in `state` will not be cleared by suspending as effects are not run, or cleaned up,
   *   when components are suspended / resumed.
   * - After the post suspense render, we can use the `portalRef` (which was captured in an effect)
   *   to continue to portal into.
   *
   * _Why not store `portalRef` in `state` in `<PanelSplitterProvider>`?_
   *
   * - The `portalRef` is set high in the tree, so a re-render will cause a
   *   large amount of components to re-render (eg the whole sidebar)
   * - After a suspense, we would need to do _another_ large re-render to propagate the new refs
   * - With our current approach, any changes to `portalRef` will cause a re-render low in the tree
   *   (just in the `<PanelSplitter>`)
   */

  // We want this effect to run after each render (see above)
  // eslint-disable-next-line react-hooks/exhaustive-deps
  (0, _react.useEffect)(function () {
    // Don't need to do anything
    if (!isEnabled) {
      return;
    }

    // It is safe to access refs in useEffect, even with Suspense

    var panelEl = panelRef.current;
    var portalEl = portalRef.current;
    (0, _tinyInvariant.default)(panelEl, 'panelRef not set');
    (0, _tinyInvariant.default)(portalEl, 'portal element not set');

    // Doing our own check, as this results in fewer re-renders than react
    // (which also does it's own checks to see if a re-render should occur)
    if (panelEl === panel && portalEl === portal) {
      return;
    }

    // If refs don't change, react won't cause infinite loops
    setPanel(panelEl);
    setPortal(portalEl);
  });
  if (!isEnabled) {
    return null;
  }
  if (!portal || !panel) {
    return null;
  }
  return /*#__PURE__*/React.createElement(PortaledPanelSplitter, {
    label: label,
    onResizeStart: onResizeStart,
    onResizeEnd: onResizeEnd,
    testId: testId,
    panelId: panelId,
    panel: panel,
    portal: portal,
    panelWidth: panelWidth,
    onCompleteResize: onCompleteResize,
    getResizeBounds: getResizeBounds,
    resizingCssVar: resizingCssVar,
    position: position
  });
};
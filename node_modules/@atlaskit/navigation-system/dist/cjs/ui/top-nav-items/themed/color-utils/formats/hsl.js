"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.parseHsl = parseHsl;
var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));
var rgbOffset = {
  red: 0,
  // Pure red has a hue of 0 degrees
  green: 120,
  // Pure green has a hue of 120 degrees
  blue: 240 // Pure blue has a hue of 240 degrees
};

/**
 * Returns the contribution of the given RGB channel to the provided hue.
 *
 * Maximum value is 1, meaning it's the main channel for the hue
 * Minimum value is -1, meaning it doesn't contribute to the hue at all
 *
 * The function looks like a single trapezoidal wave that is
 * horizontally shifted according to the hue offset of the given channel.
 */
var getChannelContributionToHue = function getChannelContributionToHue(_ref) {
  var rgbChannel = _ref.rgbChannel,
    hue = _ref.hue;
  var k = (360 - rgbOffset[rgbChannel] + hue) / 30 % 12;
  return Math.max(-1, Math.min(k - 3, 9 - k, 1));
};

/**
 * Derived from Wikipedia article on HSL:
 * https://en.wikipedia.org/wiki/HSL_and_HSV#HSL_to_RGB_alternative
 *
 * You can think of it as taking an RGB channel, and the saturation and lightness values
 * to construct a function mapping hue to channel intensity.
 *
 * It then evaluates the function for the given hue.
 */
var getRgbChannel = function getRgbChannel(_ref2) {
  var rgbChannel = _ref2.rgbChannel,
    _ref2$color = _ref2.color,
    hue = _ref2$color.h,
    saturation = _ref2$color.s,
    lightness = _ref2$color.l;
  var shiftY = lightness;
  var scaleY = -1 * saturation * Math.min(lightness, 1 - lightness);
  /**
   * Value between 0-1 describing how much the RGB channel contributes to the given HSL color.
   *
   * `getChannelContributionToHue` is the channel contribution for the pure hue,
   * which is why we need to adjust and scale according to saturation and lightness.
   */
  var channelContribution = shiftY + scaleY * getChannelContributionToHue({
    rgbChannel: rgbChannel,
    hue: hue
  });
  return Math.round(255 * channelContribution);
};

/**
 * Attempts to parse a legacy notation CSS `hsl()` color string.
 *
 * Returns `null` on failure.
 */
function parseHsl(color) {
  /**
   * I was creating increasingly complex regular expressions, aiming for correct parsing.
   *
   * I decided to be pragmatic and just opt for what Nav 3 does (through the `chromatism` library),
   * with some slight improvements.
   *
   * We can refine it as needed.
   *
   * Known limitations of this approach:
   *
   * - It is overly permissive and will allow some invalid syntax,
   *   for example `hsl(1, 2, 3, 4, 5, 6, 7)` where it would just extract the first 3 parameters
   * - Only the integer parts of non-integers will be parsed
   * - Only supports the legacy, comma-separated syntax
   */
  var _color$replace$split$ = color.replace(/hsl\(|[)%\s]/g, '').split(',').map(function (value) {
      return parseInt(value, 10);
    }),
    _color$replace$split$2 = (0, _slicedToArray2.default)(_color$replace$split$, 3),
    h = _color$replace$split$2[0],
    s = _color$replace$split$2[1],
    l = _color$replace$split$2[2];
  if ([h, s, l].some(function (channel) {
    return !Number.isInteger(channel);
  })) {
    if (process.env.NODE_ENV !== 'production') {
      // eslint-disable-next-line no-console
      console.error("parseHsl failed to parse input: '".concat(color, "'"));
    }
    return null;
  }

  /**
   * Normalized HSL value so that:
   *
   * - hue angle is from 0 (inclusive) to 360 (not inclusive)
   * - saturation and lightness percentages are expressed as fractional values from 0 to 1
   */
  var normal = {
    h: h % 360,
    s: Math.min(s / 100, 1),
    l: Math.min(l / 100, 1)
  };
  return {
    r: getRgbChannel({
      rgbChannel: 'red',
      color: normal
    }),
    g: getRgbChannel({
      rgbChannel: 'green',
      color: normal
    }),
    b: getRgbChannel({
      rgbChannel: 'blue',
      color: normal
    })
  };
}
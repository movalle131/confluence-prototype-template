"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getCustomThemeStyles = getCustomThemeStyles;
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
var _logoRenderer = require("../nav-logo/logo-renderer");
var _button = require("./button");
var _colorUtils = require("./color-utils");
var _hex = require("./color-utils/formats/hex");
var _palette = require("./palette");
var _search = require("./search");
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { (0, _defineProperty2.default)(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
/**
 * Expects colors to be passed as `RGB` objects.
 *
 * Allows `string` for hex strings only, for backwards compatibility.
 * This will likely be removed in the future.
 *
 * Allows `null` for ergonomic reasons, because our color parsing utilities can return
 * `null` if they cannot parse a color string.
 */

function toRGBString(_ref) {
  var r = _ref.r,
    g = _ref.g,
    b = _ref.b;
  return "rgb(".concat(r, ", ").concat(g, ", ").concat(b, ")");
}
function toRGBAString(_ref2) {
  var r = _ref2.r,
    g = _ref2.g,
    b = _ref2.b,
    a = _ref2.a;
  return "rgba(".concat(r, ", ").concat(g, ", ").concat(b, ", ").concat(a, ")");
}
// Using raw hex codes because custom colors break out of the tokens model
// We will need to invert the colors based on backgroundColor independently of the app's color mode (dark/light)
// Values here are not final
var buttonStyles = {
  light: (0, _defineProperty2.default)((0, _defineProperty2.default)((0, _defineProperty2.default)((0, _defineProperty2.default)((0, _defineProperty2.default)((0, _defineProperty2.default)((0, _defineProperty2.default)((0, _defineProperty2.default)((0, _defineProperty2.default)({}, _button.themedButtonBackground, 'transparent'), _button.themedButtonBackgroundHovered, _palette.palette.Neutral200A), _button.themedButtonBackgroundPressed, _palette.palette.Neutral300A), _button.themedButtonBorder, _palette.palette.Neutral300A), _button.themedButtonSelectedBackground, _palette.palette.Neutral300A), _button.themedButtonSelectedBackgroundHovered, _palette.palette.Neutral400A), _button.themedButtonSelectedBackgroundPressed, _palette.palette.Neutral500A), _button.themedButtonDisabledText, _palette.palette.Neutral400A), _button.themedButtonDisabledBackground, _palette.palette.Neutral100A),
  dark: (0, _defineProperty2.default)((0, _defineProperty2.default)((0, _defineProperty2.default)((0, _defineProperty2.default)((0, _defineProperty2.default)((0, _defineProperty2.default)((0, _defineProperty2.default)((0, _defineProperty2.default)((0, _defineProperty2.default)({}, _button.themedButtonBackground, 'transparent'), _button.themedButtonBackgroundHovered, _palette.palette.DarkNeutral200A), _button.themedButtonBackgroundPressed, _palette.palette.DarkNeutral300A), _button.themedButtonBorder, _palette.palette.DarkNeutral300A), _button.themedButtonSelectedBackground, _palette.palette.DarkNeutral300A), _button.themedButtonSelectedBackgroundHovered, _palette.palette.DarkNeutral400A), _button.themedButtonSelectedBackgroundPressed, _palette.palette.DarkNeutral500A), _button.themedButtonDisabledText, _palette.palette.DarkNeutral400A), _button.themedButtonDisabledBackground, _palette.palette.DarkNeutral100A)
};
var logoStyles = {
  light: (0, _defineProperty2.default)((0, _defineProperty2.default)({}, _logoRenderer.themedLogoIcon, _palette.palette.DarkNeutral0), _logoRenderer.themedLogoText, _palette.palette.DarkNeutral0),
  dark: (0, _defineProperty2.default)((0, _defineProperty2.default)({}, _logoRenderer.themedLogoIcon, _palette.palette.Neutral0), _logoRenderer.themedLogoText, _palette.palette.Neutral0)
};

/**
 * Provides a `style` prop value for the `TopNav` that defines required CSS variables.
 *
 * If a provided `backgroundColor` or `highlightColor` cannot be parsed,
 * then `null` will be returned.
 */
function getCustomThemeStyles(_ref3) {
  var backgroundColor = _ref3.backgroundColor,
    highlightColor = _ref3.highlightColor;
  var backgroundRgb = typeof backgroundColor === 'string' ? (0, _hex.parseHex)(backgroundColor) : backgroundColor;
  var highlightRgb = typeof highlightColor === 'string' ? (0, _hex.parseHex)(highlightColor) : highlightColor;
  if (!backgroundRgb || !highlightRgb) {
    return null;
  }
  var textColor = (0, _colorUtils.getTextColor)(backgroundRgb);
  var colorMode = (0, _colorUtils.getColorMode)(backgroundRgb);
  var highlightTextColor = (0, _colorUtils.getTextColor)(highlightRgb);
  return _objectSpread(_objectSpread(_objectSpread(_objectSpread({
    backgroundColor: toRGBString(backgroundRgb),
    color: textColor.hex
  }, buttonStyles[colorMode]), logoStyles[colorMode]), getSelectedStyles({
    backgroundColor: backgroundRgb,
    colorMode: colorMode
  })), {}, (0, _defineProperty2.default)((0, _defineProperty2.default)((0, _defineProperty2.default)((0, _defineProperty2.default)((0, _defineProperty2.default)((0, _defineProperty2.default)({}, _search.themedSearchBorder, toRGBAString(_objectSpread(_objectSpread({}, textColor.rgb), {}, {
    a: 0.5
  }))), _search.themedSearchBorderFocused, toRGBAString(_objectSpread(_objectSpread({}, highlightRgb), {}, {
    a: 0.8
  }))), _button.themedButtonPrimaryBackground, toRGBString(highlightRgb)), _button.themedButtonPrimaryBackgroundHovered, toRGBAString(_objectSpread(_objectSpread({}, highlightRgb), {}, {
    a: 0.8
  }))), _button.themedButtonPrimaryBackgroundPressed, toRGBAString(_objectSpread(_objectSpread({}, highlightRgb), {}, {
    a: 0.65
  }))), _button.themedButtonPrimaryText, highlightTextColor.hex));
}

/**
 * Precomputed RGBA values for the selected backgrounds
 */
var selectedBackgroundRGBA = {
  light: _palette.paletteRgba.Neutral300A,
  dark: _palette.paletteRgba.DarkNeutral300A
};
function getSelectedStyles(_ref4) {
  var backgroundColor = _ref4.backgroundColor,
    colorMode = _ref4.colorMode;
  /**
   * The background color of the selected button in its default state.
   *
   * We are referring to this as a foreground color because it is semi-transparent,
   * so is not the actual color displayed when the button is on top of a background color.
   */
  var foregroundColor = selectedBackgroundRGBA[colorMode];

  /**
   * The blended color seen when the selected background is over the top bar.
   */
  var blendedBackground = (0, _colorUtils.simpleAlphaComposite)({
    background: backgroundColor,
    foreground: foregroundColor
  });
  return (0, _defineProperty2.default)((0, _defineProperty2.default)({}, _button.themedButtonSelectedText, (0, _colorUtils.getTextColor)(blendedBackground).hex), _button.themedButtonSelectedBorder, (0, _colorUtils.isLight)(blendedBackground) ? _palette.palette.Neutral1100 : _palette.palette.DarkNeutral1100);
}
/* flyout-menu-item-content.tsx generated by @compiled/babel-plugin v0.36.1 */
import _slicedToArray from "@babel/runtime/helpers/slicedToArray";
import "./flyout-menu-item-content.compiled.css";
import { ax, ix } from "@compiled/react/runtime";
import React, { forwardRef, useCallback, useContext, useEffect, useMemo, useRef, useState } from 'react';
import mergeRefs from '@atlaskit/ds-lib/merge-refs';
import { fg } from '@atlaskit/platform-feature-flags';
import { PopupContent } from '@atlaskit/popup/experimental';
import { SetIsOpenContext } from './flyout-menu-item-context';
var flyoutMenuItemContentStyles = {
  root: "_1q51u2gc _85i5u2gc _bozgu2gc _y4tiu2gc _14b51kdj"
};
/**
 * __FlyoutMenuItemContent__
 *
 * The content that appears when the flyout menu is open.
 */
export var FlyoutMenuItemContent = /*#__PURE__*/forwardRef(function (_ref, forwardedRef) {
  var children = _ref.children,
    containerTestId = _ref.containerTestId,
    onClose = _ref.onClose,
    autoFocus = _ref.autoFocus;
  var setIsOpen = useContext(SetIsOpenContext);
  var handleClose = useCallback(function () {
    onClose === null || onClose === void 0 || onClose();
    setIsOpen(false);
  }, [setIsOpen, onClose]);
  return /*#__PURE__*/React.createElement(PopupContent, {
    appearance: "UNSAFE_modal-below-sm",
    onClose: handleClose,
    placement: "right-start"
    // Using a capture event listener so that we are more resilient against
    // code that stops events. We _really_ want to close the flyout whenever
    // user user clicks outside the flyout content
    ,
    shouldUseCaptureOnOutsideClick: fg('platform_dst_nav4_flyout_use_capture_outside'),
    shouldFitViewport: true,
    testId: containerTestId,
    xcss: flyoutMenuItemContentStyles.root,
    autoFocus: autoFocus
    /**
     * Disabling GPU acceleration removes the use of `transform` by popper.js for this popup.
     *
     * This allows makers to use popups with `shouldRenderToParent` inside the flyout.
     *
     * Without this, the `transform` makes the flyout the containing element for fixed positioning.
     * Because the flyout is also a scroll container then any nested, layered element is unable to
     * escape the flyout.
     *
     * Disabling the `transform` is the simplest way to resolve this layering issue,
     * and should have negligible performance impacts, because the flyout menus should rarely
     * need to be repositioned.
     */,
    shouldDisableGpuAcceleration: true
  }, function (_ref2) {
    var update = _ref2.update;
    return /*#__PURE__*/React.createElement(UpdatePopperOnContentResize, {
      ref: forwardedRef,
      update: update
    }, children);
  });
});
function createResizeObserver(update) {
  return new ResizeObserver(update);
}

/**
 * Will call the Popper.js `update()` method to recalculate positioning, when the flyout menu changes size.
 * This is the size of the scroll container, NOT the scroll content.
 *
 * We could potentially bake this into `@atlaskit/popup` or `@atlaskit/popper` but there are a few
 * reasons to keep it scoped to flyout menus for now:
 *
 * 1. It's easier to unwind
 * 2. We've only had bug reports for flyout menus
 * 3. Popup exposes the `update` function so consumers can already do this themselves if necessary
 * 4. Flyout menus are a lot more restricted to other popups, it might not make sense more generally
 */
var UpdatePopperOnContentResize = /*#__PURE__*/forwardRef(function (_ref3, forwardedRef) {
  var update = _ref3.update,
    children = _ref3.children;
  /**
   * Storing our `update` function in a ref so that we have a stable reference to it.
   * We need this because our `ResizeObserver` callback cannot be changed after creating it.
   */
  var updateRef = useRef(update);
  useEffect(function () {
    updateRef.current = update;
  }, [update]);

  /**
   * Stable function that calls the latest `update` function by calling it through the stable ref.
   */
  var triggerUpdate = useCallback(function () {
    var _updateRef$current;
    (_updateRef$current = updateRef.current) === null || _updateRef$current === void 0 || _updateRef$current.call(updateRef);
  }, []);
  var _useState = useState(function () {
      return createResizeObserver(triggerUpdate);
    }),
    _useState2 = _slicedToArray(_useState, 1),
    resizeObserver = _useState2[0];

  /**
   * This is a callback ref that will update which `HTMLElement` we are observing,
   * if or when the underlying `HTMLElement` changes or unmounts.
   */
  var observeCallbackRef = useCallback(function (element) {
    /**
     * Unobserves all observed elements.
     * Allows us to cleanup without needing to store a reference to the previous element.
     */
    resizeObserver.disconnect();
    if (!element) {
      return;
    }
    resizeObserver.observe(element);
  }, [resizeObserver]);

  /**
   * We need to memoize the ref otherwise `triggerUpdate` is repeatedly called.
   *
   * This stems from ResizeObserver firing once after calling `.observe()` even if there
   * was no resize.
   *
   * Without memoizing the ref, the update causes a rerender, which causes the ref to
   * get recreated, which triggers an update and so on in a loop.
   */
  var ref = useMemo(function () {
    return mergeRefs([forwardedRef, observeCallbackRef]);
  }, [forwardedRef, observeCallbackRef]);
  return /*#__PURE__*/React.createElement("div", {
    ref: ref
  }, children);
});
import _defineProperty from "@babel/runtime/helpers/defineProperty";
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
import { themedLogoIcon, themedLogoText } from '../nav-logo/logo-renderer';
import { themedButtonBackground, themedButtonBackgroundHovered, themedButtonBackgroundPressed, themedButtonBorder, themedButtonDisabledBackground, themedButtonDisabledText, themedButtonPrimaryBackground, themedButtonPrimaryBackgroundHovered, themedButtonPrimaryBackgroundPressed, themedButtonPrimaryText, themedButtonSelectedBackground, themedButtonSelectedBackgroundHovered, themedButtonSelectedBackgroundPressed, themedButtonSelectedBorder, themedButtonSelectedText } from './button';
import { getColorMode, getTextColor, isLight, simpleAlphaComposite } from './color-utils';
import { parseHex } from './color-utils/formats/hex';
import { palette, paletteRgba } from './palette';
import { themedSearchBorder, themedSearchBorderFocused } from './search';

/**
 * Expects colors to be passed as `RGB` objects.
 *
 * Allows `string` for hex strings only, for backwards compatibility.
 * This will likely be removed in the future.
 *
 * Allows `null` for ergonomic reasons, because our color parsing utilities can return
 * `null` if they cannot parse a color string.
 */

function toRGBString(_ref) {
  var r = _ref.r,
    g = _ref.g,
    b = _ref.b;
  return "rgb(".concat(r, ", ").concat(g, ", ").concat(b, ")");
}
function toRGBAString(_ref2) {
  var r = _ref2.r,
    g = _ref2.g,
    b = _ref2.b,
    a = _ref2.a;
  return "rgba(".concat(r, ", ").concat(g, ", ").concat(b, ", ").concat(a, ")");
}
// Using raw hex codes because custom colors break out of the tokens model
// We will need to invert the colors based on backgroundColor independently of the app's color mode (dark/light)
// Values here are not final
var buttonStyles = {
  light: _defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty({}, themedButtonBackground, 'transparent'), themedButtonBackgroundHovered, palette.Neutral200A), themedButtonBackgroundPressed, palette.Neutral300A), themedButtonBorder, palette.Neutral300A), themedButtonSelectedBackground, palette.Neutral300A), themedButtonSelectedBackgroundHovered, palette.Neutral400A), themedButtonSelectedBackgroundPressed, palette.Neutral500A), themedButtonDisabledText, palette.Neutral400A), themedButtonDisabledBackground, palette.Neutral100A),
  dark: _defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty({}, themedButtonBackground, 'transparent'), themedButtonBackgroundHovered, palette.DarkNeutral200A), themedButtonBackgroundPressed, palette.DarkNeutral300A), themedButtonBorder, palette.DarkNeutral300A), themedButtonSelectedBackground, palette.DarkNeutral300A), themedButtonSelectedBackgroundHovered, palette.DarkNeutral400A), themedButtonSelectedBackgroundPressed, palette.DarkNeutral500A), themedButtonDisabledText, palette.DarkNeutral400A), themedButtonDisabledBackground, palette.DarkNeutral100A)
};
var logoStyles = {
  light: _defineProperty(_defineProperty({}, themedLogoIcon, palette.DarkNeutral0), themedLogoText, palette.DarkNeutral0),
  dark: _defineProperty(_defineProperty({}, themedLogoIcon, palette.Neutral0), themedLogoText, palette.Neutral0)
};

/**
 * Provides a `style` prop value for the `TopNav` that defines required CSS variables.
 *
 * If a provided `backgroundColor` or `highlightColor` cannot be parsed,
 * then `null` will be returned.
 */
export function getCustomThemeStyles(_ref3) {
  var backgroundColor = _ref3.backgroundColor,
    highlightColor = _ref3.highlightColor;
  var backgroundRgb = typeof backgroundColor === 'string' ? parseHex(backgroundColor) : backgroundColor;
  var highlightRgb = typeof highlightColor === 'string' ? parseHex(highlightColor) : highlightColor;
  if (!backgroundRgb || !highlightRgb) {
    return null;
  }
  var textColor = getTextColor(backgroundRgb);
  var colorMode = getColorMode(backgroundRgb);
  var highlightTextColor = getTextColor(highlightRgb);
  return _objectSpread(_objectSpread(_objectSpread(_objectSpread({
    backgroundColor: toRGBString(backgroundRgb),
    color: textColor.hex
  }, buttonStyles[colorMode]), logoStyles[colorMode]), getSelectedStyles({
    backgroundColor: backgroundRgb,
    colorMode: colorMode
  })), {}, _defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty({}, themedSearchBorder, toRGBAString(_objectSpread(_objectSpread({}, textColor.rgb), {}, {
    a: 0.5
  }))), themedSearchBorderFocused, toRGBAString(_objectSpread(_objectSpread({}, highlightRgb), {}, {
    a: 0.8
  }))), themedButtonPrimaryBackground, toRGBString(highlightRgb)), themedButtonPrimaryBackgroundHovered, toRGBAString(_objectSpread(_objectSpread({}, highlightRgb), {}, {
    a: 0.8
  }))), themedButtonPrimaryBackgroundPressed, toRGBAString(_objectSpread(_objectSpread({}, highlightRgb), {}, {
    a: 0.65
  }))), themedButtonPrimaryText, highlightTextColor.hex));
}

/**
 * Precomputed RGBA values for the selected backgrounds
 */
var selectedBackgroundRGBA = {
  light: paletteRgba.Neutral300A,
  dark: paletteRgba.DarkNeutral300A
};
function getSelectedStyles(_ref4) {
  var backgroundColor = _ref4.backgroundColor,
    colorMode = _ref4.colorMode;
  /**
   * The background color of the selected button in its default state.
   *
   * We are referring to this as a foreground color because it is semi-transparent,
   * so is not the actual color displayed when the button is on top of a background color.
   */
  var foregroundColor = selectedBackgroundRGBA[colorMode];

  /**
   * The blended color seen when the selected background is over the top bar.
   */
  var blendedBackground = simpleAlphaComposite({
    background: backgroundColor,
    foreground: foregroundColor
  });
  return _defineProperty(_defineProperty({}, themedButtonSelectedText, getTextColor(blendedBackground).hex), themedButtonSelectedBorder, isLight(blendedBackground) ? palette.Neutral1100 : palette.DarkNeutral1100);
}
/* line.tsx generated by @compiled/babel-plugin v0.36.1 */
/* eslint-disable @atlaskit/ui-styling-standard/enforce-style-prop */
import "./line.compiled.css";
import * as React from 'react';
import { ax, ix } from "@compiled/react/runtime";
import { presetStrokeColors, presetStrokeWidth } from '../presets';
var edgeToOrientationMap = {
  top: 'horizontal',
  bottom: 'horizontal',
  left: 'vertical',
  right: 'vertical'
};
var baseStyles = {
  root: "_1e0c1ule _kqswstnw _1pbykb7n _lcxvglyw _bfhkys7w _rfx31ssb _3l8810ly _kzdanqa1 _15m6ys7w _cfu11ld9 _1kt9b3bt _1cs8stnw _13y0usvi _1mp4vjfa _kfgtvjfa"
};
var orientationStyles = {
  horizontal: "_4t3i10ly _1e02fghn _rjxpidpf _z5wtuj5p",
  vertical: "_1bsb10ly _154ifghn _94n5idpf _1aukuj5p"
};
var edgeStyles = {
  top: "_154ihv0e _1auk70hn",
  right: "_1xi2hv0e _ooun70hn",
  bottom: "_94n5hv0e _19wo70hn",
  left: "_1ltvhv0e _qnec70hn"
};
var lineStartFrom = {
  // - half the terminal bleeding out the containing element
  // - half the terminal inside the containing element (we need to position the line next to this)
  terminal: function terminal(_ref) {
    var indent = _ref.indent;
    return "calc(var(--terminal-radius) + ".concat(indent, ")");
  },
  // The full terminal is inside the containing element (we need to position the line next to this)
  'terminal-no-bleed': function terminalNoBleed(_ref2) {
    var indent = _ref2.indent;
    return "calc(var(--terminal-diameter) + ".concat(indent, ")");
  },
  // No terminal to worry about, line should take up all the space
  'no-terminal': function noTerminal(_ref3) {
    var indent = _ref3.indent;
    return indent;
  }
};
export function Line(_ref4) {
  var edge = _ref4.edge,
    _ref4$gap = _ref4.gap,
    gap = _ref4$gap === void 0 ? '0px' : _ref4$gap,
    _ref4$indent = _ref4.indent,
    indent = _ref4$indent === void 0 ? '0px' : _ref4$indent,
    _ref4$strokeColor = _ref4.strokeColor,
    strokeColor = _ref4$strokeColor === void 0 ? presetStrokeColors.default : _ref4$strokeColor,
    _ref4$strokeWidth = _ref4.strokeWidth,
    strokeWidth = _ref4$strokeWidth === void 0 ? presetStrokeWidth : _ref4$strokeWidth,
    _ref4$type = _ref4.type,
    type = _ref4$type === void 0 ? 'terminal' : _ref4$type;
  var orientation = edgeToOrientationMap[edge];
  return /*#__PURE__*/React.createElement("div", {
    style: {
      // ## All

      '--stroke-color': strokeColor,
      '--stroke-width': strokeWidth,
      // Shift line and terminal on the main access to account for gaps between items
      '--main-axis-offset': "calc(-0.5 * (".concat(gap, " + var(--stroke-width)))"),
      // ## Line

      // If there is a terminal, we want the line to start from next to it
      '--line-main-axis-start': lineStartFrom[type]({
        indent: indent
      }),
      // ## Terminal

      '--terminal-display': type === 'no-terminal' ? 'none' : 'block',
      '--terminal-diameter': 'calc(var(--stroke-width) * 4)',
      '--terminal-radius': 'calc(var(--terminal-diameter) / 2)',
      // The line is positioned to account for the the terminal (--line-main-axis-start).
      // The terminal is rendered relative to the line (it's a `::before`)
      // We need to pull the terminal backwards so it sits before the start of the line
      '--terminal-main-axis-start': 'calc(-1 * var(--terminal-diameter))',
      // Pull the terminal backwards on the cross axis (eg "up" on "vertical")
      // so the center of the terminal lines up with the center of the line
      '--terminal-cross-axis-offset': 'calc(calc(var(--stroke-width) - var(--terminal-diameter)) / 2)'
    },
    className: ax([baseStyles.root, orientationStyles[orientation], edgeStyles[edge]])
  });
}

// For React.lazy
export default Line;
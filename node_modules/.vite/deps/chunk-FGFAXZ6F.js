import {
  usePreviousValue
} from "./chunk-3WCTIX47.js";
import {
  require_sidebar_collapse
} from "./chunk-PBPEGTWR.js";
import {
  require_sidebar_expand
} from "./chunk-J554AJ6T.js";
import {
  DangerouslyHoistCssVarToDocumentRoot
} from "./chunk-WV7G5RON.js";
import {
  UNSAFE_sideNavLayoutVar,
  sideNavLiveWidthVar,
  sideNavPanelSplitterId,
  sideNavVar,
  useLayoutId
} from "./chunk-W55EUAGZ.js";
import {
  IconButton
} from "./chunk-54HUSBMH.js";
import {
  DangerouslyHoistSlotSizes,
  SetSideNavVisibilityState,
  SideNavToggleButtonAttachRef,
  SideNavToggleButtonElement,
  SideNavVisibilityState,
  TopNavStartElement,
  useSideNavRef
} from "./chunk-5XHNYI7S.js";
import {
  useSkipLinkInternal
} from "./chunk-NL42P2DB.js";
import {
  media
} from "./chunk-PJFXQFKG.js";
import {
  useStableRef
} from "./chunk-PA42JLCQ.js";
import {
  OpenLayerObserverNamespaceProvider,
  useOpenLayerObserver
} from "./chunk-GSLSGJXD.js";
import {
  invariant
} from "./chunk-XUSVWCLU.js";
import {
  visually_hidden_default
} from "./chunk-73JC3HDI.js";
import {
  useId
} from "./chunk-WD223FES.js";
import {
  require_react_dom
} from "./chunk-YQ5BCTVV.js";
import {
  mergeRefs
} from "./chunk-HDYTRULV.js";
import {
  _extends,
  init_extends
} from "./chunk-TRLI7EVB.js";
import {
  ax,
  init_runtime
} from "./chunk-XC7QRLB3.js";
import {
  require_dist
} from "./chunk-4XFTJAYZ.js";
import {
  _toConsumableArray
} from "./chunk-RG5U4ZYV.js";
import {
  _defineProperty,
  _slicedToArray,
  fg,
  init_defineProperty,
  init_esm,
  init_slicedToArray
} from "./chunk-WFA677R7.js";
import {
  require_react
} from "./chunk-QJTFJ6OV.js";
import {
  __toESM
} from "./chunk-V4OQ3NZ2.js";

// node_modules/@atlaskit/navigation-system/dist/esm/ui/page-layout/panel-splitter/provider.js
var import_react2 = __toESM(require_react());

// node_modules/@atlaskit/navigation-system/dist/esm/ui/page-layout/panel-splitter/context.js
var import_react = __toESM(require_react());
var PanelSplitterContext = (0, import_react.createContext)(null);

// node_modules/@atlaskit/navigation-system/dist/esm/ui/page-layout/panel-splitter/provider.js
var PanelSplitterProvider = function PanelSplitterProvider2(_ref) {
  var panelId = _ref.panelId, panelWidth = _ref.panelWidth, onCompleteResize = _ref.onCompleteResize, getResizeBounds2 = _ref.getResizeBounds, resizingCssVar = _ref.resizingCssVar, panelRef = _ref.panelRef, _ref$position = _ref.position, position = _ref$position === void 0 ? "end" : _ref$position, _ref$isEnabled = _ref.isEnabled, isEnabled = _ref$isEnabled === void 0 ? true : _ref$isEnabled, children = _ref.children;
  var portalRef = (0, import_react2.useRef)(null);
  var context = (0, import_react2.useMemo)(function() {
    return {
      panelId,
      panelWidth,
      onCompleteResize,
      getResizeBounds: getResizeBounds2,
      resizingCssVar,
      position,
      panelRef,
      isEnabled,
      portalRef
    };
  }, [panelId, panelWidth, onCompleteResize, getResizeBounds2, resizingCssVar, position, portalRef, panelRef, isEnabled]);
  return import_react2.default.createElement(import_react2.Fragment, null, import_react2.default.createElement(PanelSplitterContext.Provider, {
    value: context
  }, children), import_react2.default.createElement("div", {
    ref: portalRef
  }));
};

// node_modules/@atlaskit/navigation-system/dist/esm/ui/page-layout/panel-splitter/panel-splitter.js
init_slicedToArray();
init_defineProperty();
var React2 = __toESM(require_react());
init_runtime();
var import_react3 = __toESM(require_react());
var import_bind_event_listener6 = __toESM(require_dist());
var import_react_dom = __toESM(require_react_dom());
import "/Users/movalle/Documents/GitHub/test-enhanced-app/node_modules/@atlaskit/navigation-system/dist/esm/ui/page-layout/panel-splitter/panel-splitter.compiled.css";

// node_modules/@atlaskit/pragmatic-drag-and-drop/dist/esm/public-utils/combine.js
function combine() {
  for (var _len = arguments.length, fns = new Array(_len), _key = 0; _key < _len; _key++) {
    fns[_key] = arguments[_key];
  }
  return function cleanup2() {
    fns.forEach(function(fn) {
      return fn();
    });
  };
}

// node_modules/@atlaskit/pragmatic-drag-and-drop/dist/esm/adapter/element-adapter.js
init_slicedToArray();
var import_bind_event_listener4 = __toESM(require_dist());

// node_modules/@atlaskit/pragmatic-drag-and-drop/dist/esm/honey-pot-fix/get-element-from-point-without-honey-pot.js
init_slicedToArray();

// node_modules/@atlaskit/pragmatic-drag-and-drop/dist/esm/honey-pot-fix/honey-pot-data-attribute.js
var honeyPotDataAttribute = "data-pdnd-honey-pot";

// node_modules/@atlaskit/pragmatic-drag-and-drop/dist/esm/honey-pot-fix/is-honey-pot-element.js
function isHoneyPotElement(target) {
  return target instanceof Element && target.hasAttribute(honeyPotDataAttribute);
}

// node_modules/@atlaskit/pragmatic-drag-and-drop/dist/esm/honey-pot-fix/get-element-from-point-without-honey-pot.js
function getElementFromPointWithoutHoneypot(client) {
  var _document$elementsFro = document.elementsFromPoint(client.x, client.y), _document$elementsFro2 = _slicedToArray(_document$elementsFro, 2), top = _document$elementsFro2[0], second = _document$elementsFro2[1];
  if (!top) {
    return null;
  }
  if (isHoneyPotElement(top)) {
    return second !== null && second !== void 0 ? second : null;
  }
  return top;
}

// node_modules/@atlaskit/pragmatic-drag-and-drop/dist/esm/honey-pot-fix/make-honey-pot-fix.js
init_defineProperty();
var import_bind_event_listener = __toESM(require_dist());

// node_modules/@atlaskit/pragmatic-drag-and-drop/dist/esm/util/max-z-index.js
var maxZIndex = 2147483647;

// node_modules/@atlaskit/pragmatic-drag-and-drop/dist/esm/honey-pot-fix/make-honey-pot-fix.js
function ownKeys(e, r) {
  var t = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    r && (o = o.filter(function(r2) {
      return Object.getOwnPropertyDescriptor(e, r2).enumerable;
    })), t.push.apply(t, o);
  }
  return t;
}
function _objectSpread(e) {
  for (var r = 1; r < arguments.length; r++) {
    var t = null != arguments[r] ? arguments[r] : {};
    r % 2 ? ownKeys(Object(t), true).forEach(function(r2) {
      _defineProperty(e, r2, t[r2]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function(r2) {
      Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
    });
  }
  return e;
}
var honeyPotSize = 2;
var halfHoneyPotSize = honeyPotSize / 2;
function floorToClosestPixel(point) {
  return {
    x: Math.floor(point.x),
    y: Math.floor(point.y)
  };
}
function pullBackByHalfHoneyPotSize(point) {
  return {
    x: point.x - halfHoneyPotSize,
    y: point.y - halfHoneyPotSize
  };
}
function preventGoingBackwardsOffScreen(point) {
  return {
    x: Math.max(point.x, 0),
    y: Math.max(point.y, 0)
  };
}
function preventGoingForwardsOffScreen(point) {
  return {
    x: Math.min(point.x, window.innerWidth - honeyPotSize),
    y: Math.min(point.y, window.innerHeight - honeyPotSize)
  };
}
function getHoneyPotRectFor(_ref) {
  var client = _ref.client;
  var point = preventGoingForwardsOffScreen(preventGoingBackwardsOffScreen(pullBackByHalfHoneyPotSize(floorToClosestPixel(client))));
  return DOMRect.fromRect({
    x: point.x,
    y: point.y,
    width: honeyPotSize,
    height: honeyPotSize
  });
}
function getRectStyles(_ref2) {
  var clientRect = _ref2.clientRect;
  return {
    left: "".concat(clientRect.left, "px"),
    top: "".concat(clientRect.top, "px"),
    width: "".concat(clientRect.width, "px"),
    height: "".concat(clientRect.height, "px")
  };
}
function isWithin(_ref3) {
  var client = _ref3.client, clientRect = _ref3.clientRect;
  return (
    // is within horizontal bounds
    client.x >= clientRect.x && client.x <= clientRect.x + clientRect.width && // is within vertical bounds
    client.y >= clientRect.y && client.y <= clientRect.y + clientRect.height
  );
}
function mountHoneyPot(_ref4) {
  var initial = _ref4.initial;
  var element = document.createElement("div");
  element.setAttribute(honeyPotDataAttribute, "true");
  var clientRect = getHoneyPotRectFor({
    client: initial
  });
  Object.assign(element.style, _objectSpread(_objectSpread({
    // Setting a background color explicitly to avoid any inherited styles.
    // Looks like this could be `opacity: 0`, but worried that _might_
    // cause the element to be ignored on some platforms.
    // When debugging, set backgroundColor to something like "red".
    backgroundColor: "transparent",
    position: "fixed",
    // Being explicit to avoid inheriting styles
    padding: 0,
    margin: 0,
    boxSizing: "border-box"
  }, getRectStyles({
    clientRect
  })), {}, {
    // We want this element to absorb pointer events,
    // it's kind of the whole point ðŸ˜‰
    pointerEvents: "auto",
    // Want to make sure the honey pot is top of everything else.
    // Don't need to worry about native drag previews, as they will
    // have been rendered (and removed) before the honey pot is rendered
    zIndex: maxZIndex
  }));
  document.body.appendChild(element);
  var unbindPointerMove = (0, import_bind_event_listener.bind)(window, {
    type: "pointermove",
    listener: function listener(event) {
      var client = {
        x: event.clientX,
        y: event.clientY
      };
      clientRect = getHoneyPotRectFor({
        client
      });
      Object.assign(element.style, getRectStyles({
        clientRect
      }));
    },
    // using capture so we are less likely to be impacted by event stopping
    options: {
      capture: true
    }
  });
  return function finish(_ref5) {
    var current = _ref5.current;
    unbindPointerMove();
    if (isWithin({
      client: current,
      clientRect
    })) {
      element.remove();
      return;
    }
    function cleanup2() {
      unbindPostDragEvents();
      element.remove();
    }
    var unbindPostDragEvents = (0, import_bind_event_listener.bindAll)(window, [
      {
        type: "pointerdown",
        listener: cleanup2
      },
      {
        type: "pointermove",
        listener: cleanup2
      },
      {
        type: "focusin",
        listener: cleanup2
      },
      {
        type: "focusout",
        listener: cleanup2
      },
      // a 'pointerdown' should happen before 'dragstart', but just being super safe
      {
        type: "dragstart",
        listener: cleanup2
      },
      // if the user has dragged something out of the window
      // and then is dragging something back into the window
      // the first events we will see are "dragenter" (and then "dragover").
      // So if we see any of these we need to clear the post drag fix.
      {
        type: "dragenter",
        listener: cleanup2
      },
      {
        type: "dragover",
        listener: cleanup2
      }
      // Not adding a "wheel" event listener, as "wheel" by itself does not
      // resolve the bug.
    ], {
      // Using `capture` so less likely to be impacted by other code stopping events
      capture: true
    });
  };
}
function makeHoneyPotFix() {
  var latestPointerMove = null;
  function bindEvents() {
    latestPointerMove = null;
    return (0, import_bind_event_listener.bind)(window, {
      type: "pointermove",
      listener: function listener(event) {
        latestPointerMove = {
          x: event.clientX,
          y: event.clientY
        };
      },
      // listening for pointer move in capture phase
      // so we are less likely to be impacted by events being stopped.
      options: {
        capture: true
      }
    });
  }
  function getOnPostDispatch() {
    var finish = null;
    return function onPostEvent(_ref6) {
      var eventName = _ref6.eventName, payload = _ref6.payload;
      if (eventName === "onDragStart") {
        var input = payload.location.initial.input;
        var initial = latestPointerMove !== null && latestPointerMove !== void 0 ? latestPointerMove : {
          x: input.clientX,
          y: input.clientY
        };
        finish = mountHoneyPot({
          initial
        });
      }
      if (eventName === "onDrop") {
        var _finish;
        var _input = payload.location.current.input;
        (_finish = finish) === null || _finish === void 0 || _finish({
          current: {
            x: _input.clientX,
            y: _input.clientY
          }
        });
        finish = null;
        latestPointerMove = null;
      }
    };
  }
  return {
    bindEvents,
    getOnPostDispatch
  };
}

// node_modules/@atlaskit/pragmatic-drag-and-drop/dist/esm/ledger/lifecycle-manager.js
var import_bind_event_listener3 = __toESM(require_dist());

// node_modules/@atlaskit/pragmatic-drag-and-drop/dist/esm/public-utils/once.js
function once(fn) {
  var cache = null;
  return function wrapped() {
    if (!cache) {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      var result = fn.apply(this, args);
      cache = {
        result
      };
    }
    return cache.result;
  };
}

// node_modules/@atlaskit/pragmatic-drag-and-drop/dist/esm/util/is-firefox.js
var isFirefox = once(function isFirefox2() {
  if (false) {
    return false;
  }
  return navigator.userAgent.includes("Firefox");
});

// node_modules/@atlaskit/pragmatic-drag-and-drop/dist/esm/util/is-safari.js
var isSafari = once(function isSafari2() {
  if (false) {
    return false;
  }
  var _navigator = navigator, userAgent = _navigator.userAgent;
  return userAgent.includes("AppleWebKit") && !userAgent.includes("Chrome");
});

// node_modules/@atlaskit/pragmatic-drag-and-drop/dist/esm/util/changing-window/count-events-for-safari.js
var import_bind_event_listener2 = __toESM(require_dist());
var symbols = {
  isLeavingWindow: Symbol("leaving"),
  isEnteringWindow: Symbol("entering")
};
function isLeavingWindowInSafari(_ref2) {
  var dragLeave = _ref2.dragLeave;
  if (!isSafari()) {
    return false;
  }
  return dragLeave.hasOwnProperty(symbols.isLeavingWindow);
}
(function fixSafari() {
  if (typeof window === "undefined") {
    return;
  }
  if (false) {
    return;
  }
  if (!isSafari()) {
    return;
  }
  function getInitialState() {
    return {
      enterCount: 0,
      isOverWindow: false
    };
  }
  var state = getInitialState();
  function resetState() {
    state = getInitialState();
  }
  (0, import_bind_event_listener2.bindAll)(
    window,
    [{
      type: "dragstart",
      listener: function listener() {
        state.enterCount = 0;
        state.isOverWindow = true;
      }
    }, {
      type: "drop",
      listener: resetState
    }, {
      type: "dragend",
      listener: resetState
    }, {
      type: "dragenter",
      listener: function listener(event) {
        if (!state.isOverWindow && state.enterCount === 0) {
          event[symbols.isEnteringWindow] = true;
        }
        state.isOverWindow = true;
        state.enterCount++;
      }
    }, {
      type: "dragleave",
      listener: function listener(event) {
        state.enterCount--;
        if (state.isOverWindow && state.enterCount === 0) {
          event[symbols.isLeavingWindow] = true;
          state.isOverWindow = false;
        }
      }
    }],
    // using `capture: true` so that adding event listeners
    // in bubble phase will have the correct symbols
    {
      capture: true
    }
  );
})();

// node_modules/@atlaskit/pragmatic-drag-and-drop/dist/esm/util/changing-window/is-from-another-window.js
function isNodeLike(target) {
  return "nodeName" in target;
}
function isFromAnotherWindow(eventTarget) {
  return isNodeLike(eventTarget) && eventTarget.ownerDocument !== document;
}

// node_modules/@atlaskit/pragmatic-drag-and-drop/dist/esm/util/changing-window/is-leaving-window.js
function isLeavingWindow(_ref) {
  var dragLeave = _ref.dragLeave;
  var type = dragLeave.type, relatedTarget = dragLeave.relatedTarget;
  if (type !== "dragleave") {
    return false;
  }
  if (isSafari()) {
    return isLeavingWindowInSafari({
      dragLeave
    });
  }
  if (relatedTarget == null) {
    return true;
  }
  if (isFirefox()) {
    return isFromAnotherWindow(relatedTarget);
  }
  return relatedTarget instanceof HTMLIFrameElement;
}

// node_modules/@atlaskit/pragmatic-drag-and-drop/dist/esm/util/detect-broken-drag.js
function getBindingsForBrokenDrags(_ref) {
  var onDragEnd = _ref.onDragEnd;
  return [
    // ## Detecting drag ending for removed draggables
    //
    // If a draggable element is removed during a drag and the user drops:
    // 1. if over a valid drop target: we get a "drop" event to know the drag is finished
    // 2. if not over a valid drop target (or cancelled): we get nothing
    // The "dragend" event will not fire on the source draggable if it has been
    // removed from the DOM.
    // So we need to figure out if a drag operation has finished by looking at other events
    // We can do this by looking at other events
    // ### First detection: "pointermove" events
    // 1. "pointermove" events cannot fire during a drag and drop operation
    // according to the spec. So if we get a "pointermove" it means that
    // the drag and drop operations has finished. So if we get a "pointermove"
    // we know that the drag is over
    // 2. ðŸ¦ŠðŸ˜¤ Drag and drop operations are _supposed_ to suppress
    // other pointer events. However, firefox will allow a few
    // pointer event to get through after a drag starts.
    // The most I've seen is 3
    {
      type: "pointermove",
      listener: /* @__PURE__ */ (function() {
        var callCount = 0;
        return function listener() {
          if (callCount < 20) {
            callCount++;
            return;
          }
          onDragEnd();
        };
      })()
    },
    // ### Second detection: "pointerdown" events
    // If we receive this event then we know that a drag operation has finished
    // and potentially another one is about to start.
    // Note: `pointerdown` fires on all browsers / platforms before "dragstart"
    {
      type: "pointerdown",
      listener: onDragEnd
    }
  ];
}

// node_modules/@atlaskit/pragmatic-drag-and-drop/dist/esm/util/get-input.js
function getInput(event) {
  return {
    altKey: event.altKey,
    button: event.button,
    buttons: event.buttons,
    ctrlKey: event.ctrlKey,
    metaKey: event.metaKey,
    shiftKey: event.shiftKey,
    clientX: event.clientX,
    clientY: event.clientY,
    pageX: event.pageX,
    pageY: event.pageY
  };
}

// node_modules/raf-schd/dist/raf-schd.esm.js
var rafSchd = function rafSchd2(fn) {
  var lastArgs = [];
  var frameId = null;
  var wrapperFn = function wrapperFn2() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    lastArgs = args;
    if (frameId) {
      return;
    }
    frameId = requestAnimationFrame(function() {
      frameId = null;
      fn.apply(void 0, lastArgs);
    });
  };
  wrapperFn.cancel = function() {
    if (!frameId) {
      return;
    }
    cancelAnimationFrame(frameId);
    frameId = null;
  };
  return wrapperFn;
};
var raf_schd_esm_default = rafSchd;

// node_modules/@atlaskit/pragmatic-drag-and-drop/dist/esm/ledger/dispatch-consumer-event.js
var scheduleOnDrag = raf_schd_esm_default(function(fn) {
  return fn();
});
var dragStart = /* @__PURE__ */ (function() {
  var scheduled = null;
  function schedule(fn) {
    var frameId = requestAnimationFrame(function() {
      scheduled = null;
      fn();
    });
    scheduled = {
      frameId,
      fn
    };
  }
  function flush() {
    if (scheduled) {
      cancelAnimationFrame(scheduled.frameId);
      scheduled.fn();
      scheduled = null;
    }
  }
  return {
    schedule,
    flush
  };
})();
function makeDispatch(_ref) {
  var source = _ref.source, initial = _ref.initial, dispatchEvent = _ref.dispatchEvent;
  var previous = {
    dropTargets: []
  };
  function safeDispatch(args) {
    dispatchEvent(args);
    previous = {
      dropTargets: args.payload.location.current.dropTargets
    };
  }
  var dispatch = {
    start: function start3(_ref2) {
      var nativeSetDragImage = _ref2.nativeSetDragImage;
      var location = {
        current: initial,
        previous,
        initial
      };
      safeDispatch({
        eventName: "onGenerateDragPreview",
        payload: {
          source,
          location,
          nativeSetDragImage
        }
      });
      dragStart.schedule(function() {
        safeDispatch({
          eventName: "onDragStart",
          payload: {
            source,
            location
          }
        });
      });
    },
    dragUpdate: function dragUpdate(_ref3) {
      var current = _ref3.current;
      dragStart.flush();
      scheduleOnDrag.cancel();
      safeDispatch({
        eventName: "onDropTargetChange",
        payload: {
          source,
          location: {
            initial,
            previous,
            current
          }
        }
      });
    },
    drag: function drag(_ref4) {
      var current = _ref4.current;
      scheduleOnDrag(function() {
        dragStart.flush();
        var location = {
          initial,
          previous,
          current
        };
        safeDispatch({
          eventName: "onDrag",
          payload: {
            source,
            location
          }
        });
      });
    },
    drop: function drop(_ref5) {
      var current = _ref5.current, updatedSourcePayload = _ref5.updatedSourcePayload;
      dragStart.flush();
      scheduleOnDrag.cancel();
      safeDispatch({
        eventName: "onDrop",
        payload: {
          source: updatedSourcePayload !== null && updatedSourcePayload !== void 0 ? updatedSourcePayload : source,
          location: {
            current,
            previous,
            initial
          }
        }
      });
    }
  };
  return dispatch;
}

// node_modules/@atlaskit/pragmatic-drag-and-drop/dist/esm/ledger/lifecycle-manager.js
var globalState = {
  isActive: false
};
function canStart() {
  return !globalState.isActive;
}
function getNativeSetDragImage(event) {
  if (event.dataTransfer) {
    return event.dataTransfer.setDragImage.bind(event.dataTransfer);
  }
  return null;
}
function hasHierarchyChanged(_ref) {
  var current = _ref.current, next = _ref.next;
  if (current.length !== next.length) {
    return true;
  }
  for (var i = 0; i < current.length; i++) {
    if (current[i].element !== next[i].element) {
      return true;
    }
  }
  return false;
}
function start(_ref2) {
  var event = _ref2.event, dragType = _ref2.dragType, getDropTargetsOver = _ref2.getDropTargetsOver, dispatchEvent = _ref2.dispatchEvent;
  if (!canStart()) {
    return;
  }
  var initial = getStartLocation({
    event,
    dragType,
    getDropTargetsOver
  });
  globalState.isActive = true;
  var state = {
    current: initial
  };
  setDropEffectOnEvent({
    event,
    current: initial.dropTargets
  });
  var dispatch = makeDispatch({
    source: dragType.payload,
    dispatchEvent,
    initial
  });
  function updateState(next) {
    var hasChanged = hasHierarchyChanged({
      current: state.current.dropTargets,
      next: next.dropTargets
    });
    state.current = next;
    if (hasChanged) {
      dispatch.dragUpdate({
        current: state.current
      });
    }
  }
  function onUpdateEvent(event2) {
    var input = getInput(event2);
    var target = isHoneyPotElement(event2.target) ? getElementFromPointWithoutHoneypot({
      x: input.clientX,
      y: input.clientY
    }) : event2.target;
    var nextDropTargets = getDropTargetsOver({
      target,
      input,
      source: dragType.payload,
      current: state.current.dropTargets
    });
    if (nextDropTargets.length) {
      event2.preventDefault();
      setDropEffectOnEvent({
        event: event2,
        current: nextDropTargets
      });
    }
    updateState({
      dropTargets: nextDropTargets,
      input
    });
  }
  function cancel() {
    if (state.current.dropTargets.length) {
      updateState({
        dropTargets: [],
        input: state.current.input
      });
    }
    dispatch.drop({
      current: state.current,
      updatedSourcePayload: null
    });
    finish();
  }
  function finish() {
    globalState.isActive = false;
    unbindEvents2();
  }
  var unbindEvents2 = (0, import_bind_event_listener3.bindAll)(
    window,
    [{
      // ðŸ‘‹ Note: we are repurposing the `dragover` event as our `drag` event
      // this is because firefox does not publish pointer coordinates during
      // a `drag` event, but does for every other type of drag event
      // `dragover` fires on all elements that are being dragged over
      // Because we are binding to `window` - our `dragover` is effectively the same as a `drag`
      // ðŸ¦ŠðŸ˜¤
      type: "dragover",
      listener: function listener(event2) {
        onUpdateEvent(event2);
        dispatch.drag({
          current: state.current
        });
      }
    }, {
      type: "dragenter",
      listener: onUpdateEvent
    }, {
      type: "dragleave",
      listener: function listener(event2) {
        if (!isLeavingWindow({
          dragLeave: event2
        })) {
          return;
        }
        updateState({
          input: state.current.input,
          dropTargets: []
        });
        if (dragType.startedFrom === "external") {
          cancel();
        }
      }
    }, {
      // A "drop" can only happen if the browser allowed the drop
      type: "drop",
      listener: function listener(event2) {
        state.current = {
          dropTargets: state.current.dropTargets,
          input: getInput(event2)
        };
        if (!state.current.dropTargets.length) {
          cancel();
          return;
        }
        event2.preventDefault();
        setDropEffectOnEvent({
          event: event2,
          current: state.current.dropTargets
        });
        dispatch.drop({
          current: state.current,
          // When dropping something native, we need to extract the latest
          // `.items` from the "drop" event as it is now accessible
          updatedSourcePayload: dragType.type === "external" ? dragType.getDropPayload(event2) : null
        });
        finish();
      }
    }, {
      // "dragend" fires when on the drag source (eg a draggable element)
      // when the drag is finished.
      // "dragend" will fire after "drop" (if there was a successful drop)
      // "dragend" does not fire if the draggable source has been removed during the drag
      // or for external drag sources (eg files)
      // This "dragend" listener will not fire if there was a successful drop
      // as we will have already removed the event listener
      type: "dragend",
      listener: function listener(event2) {
        state.current = {
          dropTargets: state.current.dropTargets,
          input: getInput(event2)
        };
        cancel();
      }
    }].concat(_toConsumableArray(getBindingsForBrokenDrags({
      onDragEnd: cancel
    }))),
    // Once we have started a managed drag operation it is important that we see / own all drag events
    // We got one adoption bug pop up where some code was stopping (`event.stopPropagation()`)
    // all "drop" events in the bubble phase on the `document.body`.
    // This meant that we never saw the "drop" event.
    {
      capture: true
    }
  );
  dispatch.start({
    nativeSetDragImage: getNativeSetDragImage(event)
  });
}
function setDropEffectOnEvent(_ref3) {
  var _current$;
  var event = _ref3.event, current = _ref3.current;
  var innerMost = (_current$ = current[0]) === null || _current$ === void 0 ? void 0 : _current$.dropEffect;
  if (innerMost != null && event.dataTransfer) {
    event.dataTransfer.dropEffect = innerMost;
  }
}
function getStartLocation(_ref4) {
  var event = _ref4.event, dragType = _ref4.dragType, getDropTargetsOver = _ref4.getDropTargetsOver;
  var input = getInput(event);
  if (dragType.startedFrom === "external") {
    return {
      input,
      dropTargets: []
    };
  }
  var dropTargets = getDropTargetsOver({
    input,
    source: dragType.payload,
    target: event.target,
    current: []
  });
  return {
    input,
    dropTargets
  };
}
var lifecycle = {
  canStart,
  start
};

// node_modules/@atlaskit/pragmatic-drag-and-drop/dist/esm/ledger/usage-ledger.js
var ledger = /* @__PURE__ */ new Map();
function registerUsage(_ref) {
  var typeKey = _ref.typeKey, mount2 = _ref.mount;
  var entry = ledger.get(typeKey);
  if (entry) {
    entry.usageCount++;
    return entry;
  }
  var initial = {
    typeKey,
    unmount: mount2(),
    usageCount: 1
  };
  ledger.set(typeKey, initial);
  return initial;
}
function register(args) {
  var entry = registerUsage(args);
  return function unregister() {
    entry.usageCount--;
    if (entry.usageCount > 0) {
      return;
    }
    entry.unmount();
    ledger.delete(args.typeKey);
  };
}

// node_modules/@atlaskit/pragmatic-drag-and-drop/dist/esm/make-adapter/make-drop-target.js
init_defineProperty();

// node_modules/@atlaskit/pragmatic-drag-and-drop/dist/esm/util/add-attribute.js
function addAttribute(element, _ref) {
  var attribute = _ref.attribute, value = _ref.value;
  element.setAttribute(attribute, value);
  return function() {
    return element.removeAttribute(attribute);
  };
}

// node_modules/@atlaskit/pragmatic-drag-and-drop/dist/esm/make-adapter/make-drop-target.js
function ownKeys2(e, r) {
  var t = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    r && (o = o.filter(function(r2) {
      return Object.getOwnPropertyDescriptor(e, r2).enumerable;
    })), t.push.apply(t, o);
  }
  return t;
}
function _objectSpread2(e) {
  for (var r = 1; r < arguments.length; r++) {
    var t = null != arguments[r] ? arguments[r] : {};
    r % 2 ? ownKeys2(Object(t), true).forEach(function(r2) {
      _defineProperty(e, r2, t[r2]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys2(Object(t)).forEach(function(r2) {
      Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
    });
  }
  return e;
}
function _createForOfIteratorHelper(r, e) {
  var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"];
  if (!t) {
    if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && "number" == typeof r.length) {
      t && (r = t);
      var _n = 0, F = function F2() {
      };
      return { s: F, n: function n() {
        return _n >= r.length ? { done: true } : { done: false, value: r[_n++] };
      }, e: function e2(r2) {
        throw r2;
      }, f: F };
    }
    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  var o, a = true, u = false;
  return { s: function s() {
    t = t.call(r);
  }, n: function n() {
    var r2 = t.next();
    return a = r2.done, r2;
  }, e: function e2(r2) {
    u = true, o = r2;
  }, f: function f() {
    try {
      a || null == t.return || t.return();
    } finally {
      if (u) throw o;
    }
  } };
}
function _unsupportedIterableToArray(r, a) {
  if (r) {
    if ("string" == typeof r) return _arrayLikeToArray(r, a);
    var t = {}.toString.call(r).slice(8, -1);
    return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0;
  }
}
function _arrayLikeToArray(r, a) {
  (null == a || a > r.length) && (a = r.length);
  for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e];
  return n;
}
function copyReverse(array) {
  return array.slice(0).reverse();
}
function makeDropTarget(_ref) {
  var typeKey = _ref.typeKey, defaultDropEffect = _ref.defaultDropEffect;
  var registry = /* @__PURE__ */ new WeakMap();
  var dropTargetDataAtt = "data-drop-target-for-".concat(typeKey);
  var dropTargetSelector = "[".concat(dropTargetDataAtt, "]");
  function addToRegistry2(args) {
    registry.set(args.element, args);
    return function() {
      return registry.delete(args.element);
    };
  }
  function dropTargetForConsumers(args) {
    if (true) {
      var existing = registry.get(args.element);
      if (existing) {
        console.warn("You have already registered a [".concat(typeKey, "] dropTarget on the same element"), {
          existing,
          proposed: args
        });
      }
      if (args.element instanceof HTMLIFrameElement) {
        console.warn("\n            We recommend not registering <iframe> elements as drop targets\n            as it can result in some strange browser event ordering.\n          ".replace(/\s{2,}/g, " ").trim());
      }
    }
    var cleanup2 = combine(addAttribute(args.element, {
      attribute: dropTargetDataAtt,
      value: "true"
    }), addToRegistry2(args));
    return once(cleanup2);
  }
  function getActualDropTargets(_ref2) {
    var _args$getData, _args$getData2, _args$getDropEffect, _args$getDropEffect2;
    var source = _ref2.source, target = _ref2.target, input = _ref2.input, _ref2$result = _ref2.result, result = _ref2$result === void 0 ? [] : _ref2$result;
    if (target == null) {
      return result;
    }
    if (!(target instanceof Element)) {
      if (target instanceof Node) {
        return getActualDropTargets({
          source,
          target: target.parentElement,
          input,
          result
        });
      }
      return result;
    }
    var closest = target.closest(dropTargetSelector);
    if (closest == null) {
      return result;
    }
    var args = registry.get(closest);
    if (args == null) {
      return result;
    }
    var feedback = {
      input,
      source,
      element: args.element
    };
    if (args.canDrop && !args.canDrop(feedback)) {
      return getActualDropTargets({
        source,
        target: args.element.parentElement,
        input,
        result
      });
    }
    var data = (_args$getData = (_args$getData2 = args.getData) === null || _args$getData2 === void 0 ? void 0 : _args$getData2.call(args, feedback)) !== null && _args$getData !== void 0 ? _args$getData : {};
    var dropEffect = (_args$getDropEffect = (_args$getDropEffect2 = args.getDropEffect) === null || _args$getDropEffect2 === void 0 ? void 0 : _args$getDropEffect2.call(args, feedback)) !== null && _args$getDropEffect !== void 0 ? _args$getDropEffect : defaultDropEffect;
    var record = {
      data,
      element: args.element,
      dropEffect,
      // we are collecting _actual_ drop targets, so these are
      // being applied _not_ due to stickiness
      isActiveDueToStickiness: false
    };
    return getActualDropTargets({
      source,
      target: args.element.parentElement,
      input,
      // Using bubble ordering. Same ordering as `event.getPath()`
      result: [].concat(_toConsumableArray(result), [record])
    });
  }
  function notifyCurrent(_ref3) {
    var eventName = _ref3.eventName, payload = _ref3.payload;
    var _iterator = _createForOfIteratorHelper(payload.location.current.dropTargets), _step;
    try {
      for (_iterator.s(); !(_step = _iterator.n()).done; ) {
        var _entry$eventName;
        var record = _step.value;
        var entry = registry.get(record.element);
        var args = _objectSpread2(_objectSpread2({}, payload), {}, {
          self: record
        });
        entry === null || entry === void 0 || (_entry$eventName = entry[eventName]) === null || _entry$eventName === void 0 || _entry$eventName.call(
          entry,
          // I cannot seem to get the types right here.
          // TS doesn't seem to like that one event can need `nativeSetDragImage`
          // @ts-expect-error
          args
        );
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }
  }
  var actions = {
    onGenerateDragPreview: notifyCurrent,
    onDrag: notifyCurrent,
    onDragStart: notifyCurrent,
    onDrop: notifyCurrent,
    onDropTargetChange: function onDropTargetChange(_ref4) {
      var payload = _ref4.payload;
      var isCurrent = new Set(payload.location.current.dropTargets.map(function(record2) {
        return record2.element;
      }));
      var visited = /* @__PURE__ */ new Set();
      var _iterator2 = _createForOfIteratorHelper(payload.location.previous.dropTargets), _step2;
      try {
        for (_iterator2.s(); !(_step2 = _iterator2.n()).done; ) {
          var _entry$onDropTargetCh;
          var record = _step2.value;
          visited.add(record.element);
          var entry = registry.get(record.element);
          var isOver = isCurrent.has(record.element);
          var args = _objectSpread2(_objectSpread2({}, payload), {}, {
            self: record
          });
          entry === null || entry === void 0 || (_entry$onDropTargetCh = entry.onDropTargetChange) === null || _entry$onDropTargetCh === void 0 || _entry$onDropTargetCh.call(entry, args);
          if (!isOver) {
            var _entry$onDragLeave;
            entry === null || entry === void 0 || (_entry$onDragLeave = entry.onDragLeave) === null || _entry$onDragLeave === void 0 || _entry$onDragLeave.call(entry, args);
          }
        }
      } catch (err) {
        _iterator2.e(err);
      } finally {
        _iterator2.f();
      }
      var _iterator3 = _createForOfIteratorHelper(payload.location.current.dropTargets), _step3;
      try {
        for (_iterator3.s(); !(_step3 = _iterator3.n()).done; ) {
          var _entry$onDropTargetCh2, _entry$onDragEnter;
          var _record = _step3.value;
          if (visited.has(_record.element)) {
            continue;
          }
          var _args = _objectSpread2(_objectSpread2({}, payload), {}, {
            self: _record
          });
          var _entry = registry.get(_record.element);
          _entry === null || _entry === void 0 || (_entry$onDropTargetCh2 = _entry.onDropTargetChange) === null || _entry$onDropTargetCh2 === void 0 || _entry$onDropTargetCh2.call(_entry, _args);
          _entry === null || _entry === void 0 || (_entry$onDragEnter = _entry.onDragEnter) === null || _entry$onDragEnter === void 0 || _entry$onDragEnter.call(_entry, _args);
        }
      } catch (err) {
        _iterator3.e(err);
      } finally {
        _iterator3.f();
      }
    }
  };
  function dispatchEvent(args) {
    actions[args.eventName](args);
  }
  function getIsOver(_ref5) {
    var source = _ref5.source, target = _ref5.target, input = _ref5.input, current = _ref5.current;
    var actual = getActualDropTargets({
      source,
      target,
      input
    });
    if (actual.length >= current.length) {
      return actual;
    }
    var lastCaptureOrdered = copyReverse(current);
    var actualCaptureOrdered = copyReverse(actual);
    var resultCaptureOrdered = [];
    for (var index = 0; index < lastCaptureOrdered.length; index++) {
      var _argsForLast$getIsSti;
      var last = lastCaptureOrdered[index];
      var fresh = actualCaptureOrdered[index];
      if (fresh != null) {
        resultCaptureOrdered.push(fresh);
        continue;
      }
      var parent = resultCaptureOrdered[index - 1];
      var lastParent = lastCaptureOrdered[index - 1];
      if ((parent === null || parent === void 0 ? void 0 : parent.element) !== (lastParent === null || lastParent === void 0 ? void 0 : lastParent.element)) {
        break;
      }
      var argsForLast = registry.get(last.element);
      if (!argsForLast) {
        break;
      }
      var feedback = {
        input,
        source,
        element: argsForLast.element
      };
      if (argsForLast.canDrop && !argsForLast.canDrop(feedback)) {
        break;
      }
      if (!((_argsForLast$getIsSti = argsForLast.getIsSticky) !== null && _argsForLast$getIsSti !== void 0 && _argsForLast$getIsSti.call(argsForLast, feedback))) {
        break;
      }
      resultCaptureOrdered.push(_objectSpread2(_objectSpread2({}, last), {}, {
        // making it clear to consumers this drop target is active due to stickiness
        isActiveDueToStickiness: true
      }));
    }
    return copyReverse(resultCaptureOrdered);
  }
  return {
    dropTargetForConsumers,
    getIsOver,
    dispatchEvent
  };
}

// node_modules/@atlaskit/pragmatic-drag-and-drop/dist/esm/make-adapter/make-monitor.js
init_defineProperty();
function _createForOfIteratorHelper2(r, e) {
  var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"];
  if (!t) {
    if (Array.isArray(r) || (t = _unsupportedIterableToArray2(r)) || e && r && "number" == typeof r.length) {
      t && (r = t);
      var _n = 0, F = function F2() {
      };
      return { s: F, n: function n() {
        return _n >= r.length ? { done: true } : { done: false, value: r[_n++] };
      }, e: function e2(r2) {
        throw r2;
      }, f: F };
    }
    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  var o, a = true, u = false;
  return { s: function s() {
    t = t.call(r);
  }, n: function n() {
    var r2 = t.next();
    return a = r2.done, r2;
  }, e: function e2(r2) {
    u = true, o = r2;
  }, f: function f() {
    try {
      a || null == t.return || t.return();
    } finally {
      if (u) throw o;
    }
  } };
}
function _unsupportedIterableToArray2(r, a) {
  if (r) {
    if ("string" == typeof r) return _arrayLikeToArray2(r, a);
    var t = {}.toString.call(r).slice(8, -1);
    return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray2(r, a) : void 0;
  }
}
function _arrayLikeToArray2(r, a) {
  (null == a || a > r.length) && (a = r.length);
  for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e];
  return n;
}
function ownKeys3(e, r) {
  var t = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    r && (o = o.filter(function(r2) {
      return Object.getOwnPropertyDescriptor(e, r2).enumerable;
    })), t.push.apply(t, o);
  }
  return t;
}
function _objectSpread3(e) {
  for (var r = 1; r < arguments.length; r++) {
    var t = null != arguments[r] ? arguments[r] : {};
    r % 2 ? ownKeys3(Object(t), true).forEach(function(r2) {
      _defineProperty(e, r2, t[r2]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys3(Object(t)).forEach(function(r2) {
      Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
    });
  }
  return e;
}
function makeMonitor() {
  var registry = /* @__PURE__ */ new Set();
  var dragging = null;
  function tryAddToActive(monitor) {
    if (!dragging) {
      return;
    }
    if (!monitor.canMonitor || monitor.canMonitor(dragging.canMonitorArgs)) {
      dragging.active.add(monitor);
    }
  }
  function monitorForConsumers(args) {
    var entry = _objectSpread3({}, args);
    registry.add(entry);
    tryAddToActive(entry);
    function cleanup2() {
      registry.delete(entry);
      if (dragging) {
        dragging.active.delete(entry);
      }
    }
    return once(cleanup2);
  }
  function dispatchEvent(_ref) {
    var eventName = _ref.eventName, payload = _ref.payload;
    if (eventName === "onGenerateDragPreview") {
      dragging = {
        canMonitorArgs: {
          initial: payload.location.initial,
          source: payload.source
        },
        active: /* @__PURE__ */ new Set()
      };
      var _iterator = _createForOfIteratorHelper2(registry), _step;
      try {
        for (_iterator.s(); !(_step = _iterator.n()).done; ) {
          var monitor = _step.value;
          tryAddToActive(monitor);
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
    }
    if (!dragging) {
      return;
    }
    var active = Array.from(dragging.active);
    for (var _i = 0, _active = active; _i < _active.length; _i++) {
      var _monitor = _active[_i];
      if (dragging.active.has(_monitor)) {
        var _monitor$eventName;
        (_monitor$eventName = _monitor[eventName]) === null || _monitor$eventName === void 0 || _monitor$eventName.call(_monitor, payload);
      }
    }
    if (eventName === "onDrop") {
      dragging.active.clear();
      dragging = null;
    }
  }
  return {
    dispatchEvent,
    monitorForConsumers
  };
}

// node_modules/@atlaskit/pragmatic-drag-and-drop/dist/esm/make-adapter/make-adapter.js
function makeAdapter(_ref) {
  var typeKey = _ref.typeKey, mount2 = _ref.mount, dispatchEventToSource2 = _ref.dispatchEventToSource, onPostDispatch = _ref.onPostDispatch, defaultDropEffect = _ref.defaultDropEffect;
  var monitorAPI = makeMonitor();
  var dropTargetAPI = makeDropTarget({
    typeKey,
    defaultDropEffect
  });
  function dispatchEvent(args) {
    dispatchEventToSource2 === null || dispatchEventToSource2 === void 0 || dispatchEventToSource2(args);
    dropTargetAPI.dispatchEvent(args);
    monitorAPI.dispatchEvent(args);
    onPostDispatch === null || onPostDispatch === void 0 || onPostDispatch(args);
  }
  function start3(_ref2) {
    var event = _ref2.event, dragType = _ref2.dragType;
    lifecycle.start({
      event,
      dragType,
      getDropTargetsOver: dropTargetAPI.getIsOver,
      dispatchEvent
    });
  }
  function registerUsage2() {
    function mountAdapter() {
      var api = {
        canStart: lifecycle.canStart,
        start: start3
      };
      return mount2(api);
    }
    return register({
      typeKey,
      mount: mountAdapter
    });
  }
  return {
    registerUsage: registerUsage2,
    dropTarget: dropTargetAPI.dropTargetForConsumers,
    monitor: monitorAPI.monitorForConsumers
  };
}

// node_modules/@atlaskit/pragmatic-drag-and-drop/dist/esm/util/android.js
var isAndroid = once(function isAndroid2() {
  return navigator.userAgent.toLocaleLowerCase().includes("android");
});
var androidFallbackText = "pdnd:android-fallback";

// node_modules/@atlaskit/pragmatic-drag-and-drop/dist/esm/util/media-types/text-media-type.js
var textMediaType = "text/plain";

// node_modules/@atlaskit/pragmatic-drag-and-drop/dist/esm/util/media-types/url-media-type.js
var URLMediaType = "text/uri-list";

// node_modules/@atlaskit/pragmatic-drag-and-drop/dist/esm/adapter/element-adapter-native-data-key.js
var elementAdapterNativeDataKey = "application/vnd.pdnd";

// node_modules/@atlaskit/pragmatic-drag-and-drop/dist/esm/adapter/element-adapter.js
var draggableRegistry = /* @__PURE__ */ new WeakMap();
function addToRegistry(args) {
  draggableRegistry.set(args.element, args);
  return function cleanup2() {
    draggableRegistry.delete(args.element);
  };
}
var honeyPotFix = makeHoneyPotFix();
var adapter = makeAdapter({
  typeKey: "element",
  defaultDropEffect: "move",
  mount: function mount(api) {
    return combine(honeyPotFix.bindEvents(), (0, import_bind_event_listener4.bind)(document, {
      type: "dragstart",
      listener: function listener(event) {
        var _entry$dragHandle, _entry$getInitialData, _entry$getInitialData2, _entry$dragHandle2, _entry$getInitialData3, _entry$getInitialData4;
        if (!api.canStart(event)) {
          return;
        }
        if (event.defaultPrevented) {
          return;
        }
        if (!event.dataTransfer) {
          if (true) {
            console.warn("\n              It appears as though you have are not testing DragEvents correctly.\n\n              - If you are unit testing, ensure you have polyfilled DragEvent.\n              - If you are browser testing, ensure you are dispatching drag events correctly.\n\n              Please see our testing guides for more information:\n              https://atlassian.design/components/pragmatic-drag-and-drop/core-package/testing\n            ".replace(/ {2}/g, ""));
          }
          return;
        }
        var target = event.target;
        if (!(target instanceof HTMLElement)) {
          return null;
        }
        var entry = draggableRegistry.get(target);
        if (!entry) {
          return null;
        }
        var input = getInput(event);
        var feedback = {
          element: entry.element,
          dragHandle: (_entry$dragHandle = entry.dragHandle) !== null && _entry$dragHandle !== void 0 ? _entry$dragHandle : null,
          input
        };
        if (entry.canDrag && !entry.canDrag(feedback)) {
          event.preventDefault();
          return null;
        }
        if (entry.dragHandle) {
          var over = getElementFromPointWithoutHoneypot({
            x: input.clientX,
            y: input.clientY
          });
          if (!entry.dragHandle.contains(over)) {
            event.preventDefault();
            return null;
          }
        }
        var nativeData = (_entry$getInitialData = (_entry$getInitialData2 = entry.getInitialDataForExternal) === null || _entry$getInitialData2 === void 0 ? void 0 : _entry$getInitialData2.call(entry, feedback)) !== null && _entry$getInitialData !== void 0 ? _entry$getInitialData : null;
        if (nativeData) {
          for (var _i = 0, _Object$entries = Object.entries(nativeData); _i < _Object$entries.length; _i++) {
            var _Object$entries$_i = _slicedToArray(_Object$entries[_i], 2), key = _Object$entries$_i[0], data = _Object$entries$_i[1];
            event.dataTransfer.setData(key, data !== null && data !== void 0 ? data : "");
          }
        }
        if (isAndroid() && !event.dataTransfer.types.includes(textMediaType) && !event.dataTransfer.types.includes(URLMediaType)) {
          event.dataTransfer.setData(textMediaType, androidFallbackText);
        }
        event.dataTransfer.setData(elementAdapterNativeDataKey, "");
        var payload = {
          element: entry.element,
          dragHandle: (_entry$dragHandle2 = entry.dragHandle) !== null && _entry$dragHandle2 !== void 0 ? _entry$dragHandle2 : null,
          data: (_entry$getInitialData3 = (_entry$getInitialData4 = entry.getInitialData) === null || _entry$getInitialData4 === void 0 ? void 0 : _entry$getInitialData4.call(entry, feedback)) !== null && _entry$getInitialData3 !== void 0 ? _entry$getInitialData3 : {}
        };
        var dragType = {
          type: "element",
          payload,
          startedFrom: "internal"
        };
        api.start({
          event,
          dragType
        });
      }
    }));
  },
  dispatchEventToSource: function dispatchEventToSource(_ref) {
    var _draggableRegistry$ge, _draggableRegistry$ge2;
    var eventName = _ref.eventName, payload = _ref.payload;
    (_draggableRegistry$ge = draggableRegistry.get(payload.source.element)) === null || _draggableRegistry$ge === void 0 || (_draggableRegistry$ge2 = _draggableRegistry$ge[eventName]) === null || _draggableRegistry$ge2 === void 0 || _draggableRegistry$ge2.call(
      _draggableRegistry$ge,
      // I cannot seem to get the types right here.
      // TS doesn't seem to like that one event can need `nativeSetDragImage`
      // @ts-expect-error
      payload
    );
  },
  onPostDispatch: honeyPotFix.getOnPostDispatch()
});
var dropTargetForElements = adapter.dropTarget;
var monitorForElements = adapter.monitor;
function draggable(args) {
  if (true) {
    if (args.dragHandle && !args.element.contains(args.dragHandle)) {
      console.warn("Drag handle element must be contained in draggable element", {
        element: args.element,
        dragHandle: args.dragHandle
      });
    }
  }
  if (true) {
    var existing = draggableRegistry.get(args.element);
    if (existing) {
      console.warn("You have already registered a `draggable` on the same element", {
        existing,
        proposed: args
      });
    }
  }
  var cleanup2 = combine(
    // making the draggable register the adapter rather than drop targets
    // this is because you *must* have a draggable element to start a drag
    // but you _might_ not have any drop targets immediately
    // (You might create drop targets async)
    adapter.registerUsage(),
    addToRegistry(args),
    addAttribute(args.element, {
      attribute: "draggable",
      value: "true"
    })
  );
  return once(cleanup2);
}

// node_modules/@atlaskit/pragmatic-drag-and-drop/dist/esm/public-utils/element/block-dragging-to-iframes.js
function setStyle(el, _ref) {
  var property = _ref.property, rule = _ref.rule, _ref$priority = _ref.priority, priority = _ref$priority === void 0 ? "" : _ref$priority;
  var originalValue = el.style.getPropertyValue(property);
  var originalPriority = el.style.getPropertyPriority(property);
  el.style.setProperty(property, rule, priority);
  return function cleanup2() {
    el.style.setProperty(property, originalValue, originalPriority);
  };
}
var isActive = false;
function tryStart() {
  if (isActive) {
    return;
  }
  isActive = true;
  var iframeCleanups = Array.from(document.querySelectorAll("iframe")).map(function(iframe) {
    return setStyle(iframe, {
      property: "pointer-events",
      rule: "none",
      priority: "important"
    });
  });
  var cleanup2 = combine.apply(void 0, _toConsumableArray(iframeCleanups).concat([
    // We only need this monitor for listening to the drop
    // as our monitor in `blockDraggingToIFrames()` will only
    // call this function when the drag has started
    monitorForElements({
      onDrop: function onDrop() {
        cleanup2();
      }
    }),
    function release() {
      isActive = false;
    }
  ]));
}
function blockDraggingToIFrames(_ref2) {
  var element = _ref2.element;
  return monitorForElements({
    onGenerateDragPreview: function onGenerateDragPreview(_ref3) {
      var source = _ref3.source;
      if (source.element === element) {
        tryStart();
      }
    }
  });
}

// node_modules/@atlaskit/pragmatic-drag-and-drop/dist/esm/public-utils/element/disable-native-drag-preview.js
var tinyTransparentImage = (function() {
  if (typeof window === "undefined") {
    return null;
  }
  var img = new Image();
  img.src = "data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACH5BAEAAAAALAAAAAABAAEAAAICRAEAOw==";
  return img;
})();
function disableNativeDragPreview(_ref) {
  var nativeSetDragImage = _ref.nativeSetDragImage;
  if (nativeSetDragImage && tinyTransparentImage) {
    nativeSetDragImage(tinyTransparentImage, 0, 0);
  }
}

// node_modules/@atlaskit/pragmatic-drag-and-drop/dist/esm/public-utils/prevent-unhandled.js
var import_bind_event_listener5 = __toESM(require_dist());
function acceptDrop(event) {
  if (event.defaultPrevented) {
    return;
  }
  if (event.dataTransfer) {
    event.dataTransfer.dropEffect = "move";
  }
  event.preventDefault();
}
var unbindEvents = null;
function start2() {
  cleanup();
  unbindEvents = (0, import_bind_event_listener5.bindAll)(
    window,
    [{
      type: "dragover",
      listener: acceptDrop
    }, {
      type: "dragenter",
      listener: acceptDrop
    }, {
      type: "drop",
      listener: function listener(event) {
        event.preventDefault();
        cleanup();
      }
    }, {
      type: "dragend",
      listener: cleanup
    }].concat(_toConsumableArray(getBindingsForBrokenDrags({
      onDragEnd: cleanup
    }))),
    // being clear that these are added in the bubble phase
    {
      capture: false
    }
  );
}
function cleanup() {
  var _unbindEvents;
  (_unbindEvents = unbindEvents) === null || _unbindEvents === void 0 || _unbindEvents();
  unbindEvents = null;
}
function stop() {
  var _window$event;
  if (((_window$event = window.event) === null || _window$event === void 0 ? void 0 : _window$event.type) === "drop") {
    var _window$event2;
    (_window$event2 = window.event) === null || _window$event2 === void 0 || _window$event2.preventDefault();
  }
  cleanup();
}
var preventUnhandled = {
  start: start2,
  stop
};

// node_modules/@atlaskit/navigation-system/dist/esm/ui/page-layout/panel-splitter/convert-resize-bound-to-pixels.js
function convertResizeBoundToPixels(resizeBound) {
  if (resizeBound.endsWith("vw")) {
    var maxWidthFraction = parseInt(resizeBound) / 100;
    return Math.floor(window.innerWidth * maxWidthFraction);
  }
  return Math.floor(parseInt(resizeBound));
}

// node_modules/@atlaskit/navigation-system/dist/esm/ui/page-layout/panel-splitter/get-percentage-within-pixel-bounds.js
function getPercentageWithinPixelBounds(_ref) {
  var currentWidth = _ref.currentWidth, resizeBounds = _ref.resizeBounds;
  var resizeRange = resizeBounds.max - resizeBounds.min;
  var widthAsPercentage = (currentWidth - resizeBounds.min) / resizeRange * 100;
  if (widthAsPercentage < 0) {
    return 0;
  }
  if (widthAsPercentage > 100) {
    return 100;
  }
  return Math.floor(widthAsPercentage);
}

// node_modules/@atlaskit/navigation-system/dist/esm/ui/page-layout/panel-splitter/get-width.js
var getWidthFromDragLocation = function getWidthFromDragLocation2(_ref) {
  var initialWidth = _ref.initialWidth, location = _ref.location, direction = _ref.direction, position = _ref.position;
  var diffX = location.current.input.clientX - location.initial.input.clientX;
  if (position === "end") {
    return direction === "ltr" ? initialWidth + diffX : initialWidth - diffX;
  }
  return direction === "ltr" ? initialWidth - diffX : initialWidth + diffX;
};
var getPixelWidth = function getPixelWidth2(element) {
  var _window$getComputedSt = window.getComputedStyle(element), width = _window$getComputedSt.width;
  return parseInt(width);
};

// node_modules/@atlaskit/navigation-system/dist/esm/ui/page-layout/panel-splitter/keyboard-resize-manager.js
var resizeCallbackDebounceTimeMs = 500;
function createKeyboardResizeManager(_ref) {
  var onResizeStart = _ref.onResizeStart, onResizeEnd = _ref.onResizeEnd;
  var resizingState = {
    type: "idle"
  };
  function startResizeEndTimer(_ref2) {
    var initialWidth = _ref2.initialWidth, finalWidth = _ref2.finalWidth;
    var markResizeAsEndedTimeout = setTimeout(function() {
      onResizeEnd({
        initialWidth,
        finalWidth
      });
      resizingState = {
        type: "idle"
      };
    }, resizeCallbackDebounceTimeMs);
    resizingState = {
      type: "resizing",
      initialWidth,
      abort: function abort() {
        clearTimeout(markResizeAsEndedTimeout);
      }
    };
  }
  function onResize(_ref3) {
    var initialWidth = _ref3.initialWidth, finalWidth = _ref3.finalWidth;
    if (resizingState.type === "idle") {
      onResizeStart({
        initialWidth
      });
      startResizeEndTimer({
        initialWidth,
        finalWidth
      });
      return;
    }
    if (resizingState.type === "resizing") {
      resizingState.abort();
      startResizeEndTimer({
        initialWidth: resizingState.initialWidth,
        finalWidth
      });
      return;
    }
  }
  return {
    onResize
  };
}

// node_modules/@atlaskit/navigation-system/dist/esm/ui/page-layout/panel-splitter/panel-splitter.js
function ownKeys4(e, r) {
  var t = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    r && (o = o.filter(function(r2) {
      return Object.getOwnPropertyDescriptor(e, r2).enumerable;
    })), t.push.apply(t, o);
  }
  return t;
}
function _objectSpread4(e) {
  for (var r = 1; r < arguments.length; r++) {
    var t = null != arguments[r] ? arguments[r] : {};
    r % 2 ? ownKeys4(Object(t), true).forEach(function(r2) {
      _defineProperty(e, r2, t[r2]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys4(Object(t)).forEach(function(r2) {
      Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
    });
  }
  return e;
}
var containerStyles = {
  root: "_12ji1r31 _1qu2glyw _12y31o36 _1e0cglyw _kqswstnw _u7coidpf _152tidpf _1pbykb7n _181n1ule",
  positionEnd: "_rjxpftgi",
  positionStart: "_1e02zeo2"
};
var grabAreaStyles = {
  root: "_1bsbl52n _4t3i1osq _kqswstnw _ca0qze3t _u5f3ze3t _n3tdze3t _19bvze3t _syaz1j28 _bfhk1j28 _k8m01ylx _1oec1yx9 _1lww5cps _d0aluf7j _1gavfnf5 _vp7gaqb7 _30l3aqb7 _1dr21ylx _1s5z1ylx _1cg4fnf5 _le1bfnf5 _1gglglyw _9h8h16c2"
};
var lineStyles = {
  root: "_kqswstnw _1e0c1ule _1bsbjfq9 _4t3i1osq _syaz1kw7 _bfhk1r31 _1e021v6z"
};
var panelSplitterDragDataSymbol = Symbol("panel-splitter-drag-data");
function signPanelSplitterDragData(data) {
  return _objectSpread4(_objectSpread4({}, data), {}, _defineProperty({}, panelSplitterDragDataSymbol, true));
}
function isPanelSplitterDragData(data) {
  return data[panelSplitterDragDataSymbol] === true;
}
function getTextDirection(element) {
  var _window$getComputedSt = window.getComputedStyle(element), direction = _window$getComputedSt.direction;
  return direction === "rtl" ? "rtl" : "ltr";
}
var PortaledPanelSplitter = function PortaledPanelSplitter2(_ref) {
  var label = _ref.label, onResizeStart = _ref.onResizeStart, onResizeEnd = _ref.onResizeEnd, testId = _ref.testId, panelId = _ref.panelId, panelWidth = _ref.panelWidth, onCompleteResize = _ref.onCompleteResize, getResizeBounds2 = _ref.getResizeBounds, panel = _ref.panel, portal = _ref.portal, resizingCssVar = _ref.resizingCssVar, position = _ref.position;
  var splitterRef = (0, import_react3.useRef)(null);
  var labelId = useId();
  var _useState = (0, import_react3.useState)(panelWidth), _useState2 = _slicedToArray(_useState, 2), rangeInputValue = _useState2[0], setRangeInputValue = _useState2[1];
  var _useState3 = (0, import_react3.useState)({
    // Using placeholder values here for the initial render. These will be calculated and updated when the range input is focused.
    min: 200,
    max: 500
  }), _useState4 = _slicedToArray(_useState3, 2), rangeInputBounds = _useState4[0], setRangeInputBounds = _useState4[1];
  var openLayerObserver = useOpenLayerObserver();
  (0, import_react3.useEffect)(function() {
    var splitter = splitterRef.current;
    invariant(splitter, "Splitter ref must be set");
    return combine(blockDraggingToIFrames({
      element: splitter
    }), draggable({
      element: splitter,
      onGenerateDragPreview: function onGenerateDragPreview(_ref2) {
        var nativeSetDragImage = _ref2.nativeSetDragImage;
        disableNativeDragPreview({
          nativeSetDragImage
        });
        preventUnhandled.start();
      },
      getInitialData: function getInitialData() {
        var initialWidth = getPixelWidth(panel);
        return signPanelSplitterDragData({
          panelId,
          initialWidth,
          resizingWidth: "".concat(initialWidth, "px"),
          resizeBounds: getResizeBounds2(),
          // Only computing text direction when we need it, just as the drag is starting.
          // Recomputing text direction on each new drag in case the text direction
          // has changed. This is unlikely, but being safe.
          direction: getTextDirection(panel)
        });
      },
      onDragStart: function onDragStart(_ref3) {
        var source = _ref3.source;
        invariant(isPanelSplitterDragData(source.data));
        onResizeStart === null || onResizeStart === void 0 || onResizeStart({
          initialWidth: source.data.initialWidth
        });
        openLayerObserver === null || openLayerObserver === void 0 || openLayerObserver.closeLayers();
      },
      onDrag: function onDrag(_ref4) {
        var location = _ref4.location, source = _ref4.source;
        invariant(isPanelSplitterDragData(source.data));
        var _source$data = source.data, initialWidth = _source$data.initialWidth, resizeBounds = _source$data.resizeBounds, direction = _source$data.direction;
        var targetWidth = getWidthFromDragLocation({
          initialWidth,
          location,
          direction,
          position
        });
        var resizingWidth = "clamp(".concat(resizeBounds.min, ", ").concat(targetWidth, "px, ").concat(resizeBounds.max, ")");
        panel.style.setProperty(resizingCssVar, resizingWidth);
        source.data.resizingWidth = resizingWidth;
      },
      onDrop: function onDrop(_ref5) {
        var source = _ref5.source;
        invariant(isPanelSplitterDragData(source.data));
        preventUnhandled.stop();
        invariant(isPanelSplitterDragData(source.data));
        var finalWidth = getPixelWidth(panel);
        onCompleteResize(finalWidth);
        onResizeEnd === null || onResizeEnd === void 0 || onResizeEnd({
          initialWidth: source.data.initialWidth,
          finalWidth
        });
        panel.style.removeProperty(resizingCssVar);
      }
    }));
  }, [onCompleteResize, onResizeStart, onResizeEnd, panel, resizingCssVar, panelWidth, position, openLayerObserver, panelId, getResizeBounds2]);
  var onResizeStartStableRef = useStableRef(onResizeStart);
  var onResizeEndStableRef = useStableRef(onResizeEnd);
  var _useState5 = (0, import_react3.useState)(function() {
    return createKeyboardResizeManager({
      onResizeStart: function onResizeStart2() {
        var _onResizeStartStableR;
        openLayerObserver === null || openLayerObserver === void 0 || openLayerObserver.closeLayers();
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        (_onResizeStartStableR = onResizeStartStableRef.current) === null || _onResizeStartStableR === void 0 || _onResizeStartStableR.call.apply(_onResizeStartStableR, [onResizeStartStableRef].concat(args));
      },
      onResizeEnd: function onResizeEnd2() {
        var _onResizeEndStableRef;
        for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
          args[_key2] = arguments[_key2];
        }
        return (_onResizeEndStableRef = onResizeEndStableRef.current) === null || _onResizeEndStableRef === void 0 ? void 0 : _onResizeEndStableRef.call.apply(_onResizeEndStableRef, [onResizeEndStableRef].concat(args));
      }
    });
  }), _useState6 = _slicedToArray(_useState5, 1), keyboardResizeManager = _useState6[0];
  var handleSliderInputChange = (0, import_react3.useCallback)(function(event) {
    var value = parseInt(event.target.value);
    setRangeInputValue(value);
    onCompleteResize(value);
    keyboardResizeManager.onResize({
      initialWidth: panelWidth,
      finalWidth: value
    });
  }, [onCompleteResize, panelWidth, keyboardResizeManager]);
  var resizeEventListenerCleanupFn = (0, import_react3.useRef)(null);
  var handleSliderFocus = (0, import_react3.useCallback)(function() {
    var _resizeEventListenerC;
    (_resizeEventListenerC = resizeEventListenerCleanupFn.current) === null || _resizeEventListenerC === void 0 || _resizeEventListenerC.call(resizeEventListenerCleanupFn);
    setRangeInputValue(panelWidth);
    var resizeBounds = getResizeBounds2();
    setRangeInputBounds({
      min: convertResizeBoundToPixels(resizeBounds.min),
      max: convertResizeBoundToPixels(resizeBounds.max)
    });
    resizeEventListenerCleanupFn.current = (0, import_bind_event_listener6.bind)(window, {
      type: "resize",
      listener: function updateState() {
        var resizeBounds2 = getResizeBounds2();
        setRangeInputBounds({
          min: convertResizeBoundToPixels(resizeBounds2.min),
          max: convertResizeBoundToPixels(resizeBounds2.max)
        });
      }
    });
  }, [panelWidth, getResizeBounds2]);
  var handleSliderBlur = (0, import_react3.useCallback)(function() {
    var _resizeEventListenerC2;
    (_resizeEventListenerC2 = resizeEventListenerCleanupFn.current) === null || _resizeEventListenerC2 === void 0 || _resizeEventListenerC2.call(resizeEventListenerCleanupFn);
  }, []);
  (0, import_react3.useEffect)(function() {
    return function cleanup2() {
      var _resizeEventListenerC3;
      (_resizeEventListenerC3 = resizeEventListenerCleanupFn.current) === null || _resizeEventListenerC3 === void 0 || _resizeEventListenerC3.call(resizeEventListenerCleanupFn);
    };
  }, []);
  var ariaValueText = (0, import_react3.useMemo)(function() {
    return "".concat(getPercentageWithinPixelBounds({
      currentWidth: rangeInputValue,
      resizeBounds: rangeInputBounds
    }), "% width");
  }, [rangeInputValue, rangeInputBounds]);
  return (0, import_react_dom.createPortal)(React2.createElement("div", {
    "data-testid": testId ? "".concat(testId, "-container") : void 0,
    className: ax([containerStyles.root, position === "start" && containerStyles.positionStart, position === "end" && containerStyles.positionEnd])
  }, React2.createElement("div", {
    ref: splitterRef,
    "data-testid": testId,
    className: ax([grabAreaStyles.root])
  }, React2.createElement(visually_hidden_default, null, React2.createElement("input", {
    type: "range",
    value: rangeInputValue,
    step: 20,
    min: rangeInputBounds.min,
    max: rangeInputBounds.max,
    "aria-valuetext": ariaValueText,
    "aria-labelledby": labelId,
    onChange: handleSliderInputChange,
    onFocus: handleSliderFocus,
    onBlur: handleSliderBlur
  }), React2.createElement("span", {
    id: labelId
  }, label)), React2.createElement("span", {
    className: ax([lineStyles.root])
  }))), portal);
};
var PanelSplitter = function PanelSplitter2(_ref6) {
  var label = _ref6.label, onResizeStart = _ref6.onResizeStart, onResizeEnd = _ref6.onResizeEnd, testId = _ref6.testId;
  var _useState7 = (0, import_react3.useState)(null), _useState8 = _slicedToArray(_useState7, 2), panel = _useState8[0], setPanel = _useState8[1];
  var _useState9 = (0, import_react3.useState)(null), _useState0 = _slicedToArray(_useState9, 2), portal = _useState0[0], setPortal = _useState0[1];
  var context = (0, import_react3.useContext)(PanelSplitterContext);
  invariant(context, "Panel splitter context not set");
  var panelRef = context.panelRef, portalRef = context.portalRef, isEnabled = context.isEnabled, panelId = context.panelId, panelWidth = context.panelWidth, onCompleteResize = context.onCompleteResize, getResizeBounds2 = context.getResizeBounds, resizingCssVar = context.resizingCssVar, position = context.position;
  (0, import_react3.useEffect)(function() {
    if (!isEnabled) {
      return;
    }
    var panelEl = panelRef.current;
    var portalEl = portalRef.current;
    invariant(panelEl, "panelRef not set");
    invariant(portalEl, "portal element not set");
    if (panelEl === panel && portalEl === portal) {
      return;
    }
    setPanel(panelEl);
    setPortal(portalEl);
  });
  if (!isEnabled) {
    return null;
  }
  if (!portal || !panel) {
    return null;
  }
  return React2.createElement(PortaledPanelSplitter, {
    label,
    onResizeStart,
    onResizeEnd,
    testId,
    panelId,
    panel,
    portal,
    panelWidth,
    onCompleteResize,
    getResizeBounds: getResizeBounds2,
    resizingCssVar,
    position
  });
};

// node_modules/@atlaskit/navigation-system/dist/esm/ui/page-layout/side-nav/use-expand-side-nav.js
var import_react4 = __toESM(require_react());
function useExpandSideNav() {
  var setSideNavState = (0, import_react4.useContext)(SetSideNavVisibilityState);
  var expandSideNav = (0, import_react4.useCallback)(function() {
    var _window$matchMedia = window.matchMedia("(min-width: 64rem)"), matches = _window$matchMedia.matches;
    if (matches) {
      setSideNavState(function(currentState) {
        invariant(currentState, "Side nav state should not be null");
        if (currentState.desktop === "expanded" && currentState.flyout === "closed") {
          return currentState;
        }
        return {
          mobile: currentState.mobile,
          desktop: "expanded",
          flyout: "closed"
        };
      });
    } else {
      setSideNavState(function(currentState) {
        invariant(currentState, "Side nav state should not be null");
        if (currentState.mobile === "expanded" && currentState.flyout === "closed") {
          return currentState;
        }
        return {
          desktop: currentState.desktop,
          mobile: "expanded",
          flyout: "closed"
        };
      });
    }
  }, [setSideNavState]);
  return expandSideNav;
}

// node_modules/@atlaskit/navigation-system/dist/esm/ui/page-layout/side-nav/use-toggle-side-nav.js
var import_react5 = __toESM(require_react());
function useToggleSideNav() {
  var setSideNavState = (0, import_react5.useContext)(SetSideNavVisibilityState);
  var toggleSideNav = (0, import_react5.useCallback)(function() {
    var _window$matchMedia = window.matchMedia("(min-width: 64rem)"), matches = _window$matchMedia.matches;
    if (matches) {
      setSideNavState(function(currentState) {
        invariant(currentState, "Side nav state should not be null");
        return {
          mobile: currentState.mobile,
          desktop: currentState.desktop === "expanded" ? "collapsed" : "expanded",
          flyout: "closed"
        };
      });
    } else {
      setSideNavState(function(currentState) {
        invariant(currentState, "Side nav state should not be null");
        return {
          desktop: currentState.desktop,
          mobile: currentState.mobile === "expanded" ? "collapsed" : "expanded",
          flyout: "closed"
        };
      });
    }
  }, [setSideNavState]);
  return toggleSideNav;
}

// node_modules/@atlaskit/navigation-system/dist/esm/ui/page-layout/side-nav/side-nav.js
init_extends();
init_defineProperty();
init_slicedToArray();
var React3 = __toESM(require_react());
init_runtime();
var import_react9 = __toESM(require_react());
var import_bind_event_listener7 = __toESM(require_dist());
var import_react_dom2 = __toESM(require_react_dom());
import "/Users/movalle/Documents/GitHub/test-enhanced-app/node_modules/@atlaskit/navigation-system/dist/esm/ui/page-layout/side-nav/side-nav.compiled.css";
init_esm();

// node_modules/@atlaskit/navigation-system/dist/esm/ui/page-layout/use-resizing-width-css-var-on-root-element.js
var import_react6 = __toESM(require_react());
function useResizingWidthCssVarOnRootElement(_ref) {
  var _ref$isEnabled = _ref.isEnabled, isEnabled = _ref$isEnabled === void 0 ? true : _ref$isEnabled, cssVar = _ref.cssVar, panelId = _ref.panelId;
  (0, import_react6.useEffect)(function() {
    if (!isEnabled) {
      return;
    }
    return combine(monitorForElements({
      canMonitor: function canMonitor(_ref2) {
        var source = _ref2.source;
        return source.data.panelId === panelId;
      },
      onDrag: function onDrag(_ref3) {
        var source = _ref3.source;
        if (!isPanelSplitterDragData(source.data)) {
          return;
        }
        document.documentElement.style.setProperty(cssVar, source.data.resizingWidth);
      },
      onDrop: function onDrop() {
        document.documentElement.style.removeProperty(cssVar);
      }
    }));
  }, [cssVar, isEnabled, panelId]);
  (0, import_react6.useEffect)(function() {
    if (!isEnabled) {
      return;
    }
    return function cleanupGlobalResizingCssVar() {
      document.documentElement.style.removeProperty(cssVar);
    };
  }, [cssVar, isEnabled]);
}

// node_modules/@atlaskit/navigation-system/dist/esm/ui/page-layout/side-nav/flyout-close-delay-ms.js
var sideNavFlyoutCloseDelayMs = 400;

// node_modules/@atlaskit/navigation-system/dist/esm/ui/page-layout/side-nav/use-side-nav-visibility.js
var import_react7 = __toESM(require_react());
var useSideNavVisibility = function useSideNavVisibility2() {
  var _ref = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, _ref$defaultCollapsed = _ref.defaultCollapsed, defaultCollapsed = _ref$defaultCollapsed === void 0 ? false : _ref$defaultCollapsed;
  var sideNavState = (0, import_react7.useContext)(SideNavVisibilityState);
  if (sideNavState === null) {
    return {
      isExpandedOnDesktop: !defaultCollapsed,
      isExpandedOnMobile: false
    };
  }
  return {
    isExpandedOnDesktop: sideNavState.desktop === "expanded",
    isExpandedOnMobile: sideNavState.mobile === "expanded"
  };
};

// node_modules/@atlaskit/navigation-system/dist/esm/ui/page-layout/side-nav/use-side-nav-visibility-callbacks.js
var import_react8 = __toESM(require_react());
function useSideNavVisibilityCallbacks(_ref) {
  var onExpand = _ref.onExpand, onCollapse = _ref.onCollapse, isExpandedOnDesktop = _ref.isExpandedOnDesktop, isExpandedOnMobile = _ref.isExpandedOnMobile;
  var onExpandRef = (0, import_react8.useRef)(onExpand);
  var onCollapseRef = (0, import_react8.useRef)(onCollapse);
  (0, import_react8.useEffect)(function() {
    onExpandRef.current = onExpand;
    onCollapseRef.current = onCollapse;
  }, [onExpand, onCollapse]);
  var previousIsExpandedOnDesktop = usePreviousValue(isExpandedOnDesktop);
  (0, import_react8.useEffect)(function() {
    if (previousIsExpandedOnDesktop === void 0 || previousIsExpandedOnDesktop === isExpandedOnDesktop) {
      return;
    }
    if (isExpandedOnDesktop) {
      var _onExpandRef$current;
      (_onExpandRef$current = onExpandRef.current) === null || _onExpandRef$current === void 0 || _onExpandRef$current.call(onExpandRef, {
        screen: "desktop"
      });
    } else {
      var _onCollapseRef$curren;
      (_onCollapseRef$curren = onCollapseRef.current) === null || _onCollapseRef$curren === void 0 || _onCollapseRef$curren.call(onCollapseRef, {
        screen: "desktop"
      });
    }
  }, [previousIsExpandedOnDesktop, isExpandedOnDesktop]);
  var previousIsExpandedOnMobile = usePreviousValue(isExpandedOnMobile);
  (0, import_react8.useEffect)(function() {
    if (previousIsExpandedOnMobile === void 0 || previousIsExpandedOnMobile === isExpandedOnMobile) {
      return;
    }
    if (isExpandedOnMobile) {
      var _onExpandRef$current2;
      (_onExpandRef$current2 = onExpandRef.current) === null || _onExpandRef$current2 === void 0 || _onExpandRef$current2.call(onExpandRef, {
        screen: "mobile"
      });
    } else {
      var _onCollapseRef$curren2;
      (_onCollapseRef$curren2 = onCollapseRef.current) === null || _onCollapseRef$curren2 === void 0 || _onCollapseRef$curren2.call(onCollapseRef, {
        screen: "mobile"
      });
    }
  }, [previousIsExpandedOnMobile, isExpandedOnMobile]);
}

// node_modules/@atlaskit/navigation-system/dist/esm/ui/page-layout/side-nav/side-nav.js
var panelSplitterResizingVar = "--n_snvRsz";
var widthResizeBounds = {
  min: "240px",
  max: "50vw"
};
function getResizeBounds() {
  return widthResizeBounds;
}
var openLayerObserverSideNavNamespace = "side-nav";
var styles = {
  root: "_nd5l1b6c _bfhk1bhr _16qs1cd0 _vchhusvi _4t3ieqxy _152timx3 _kqsw1if8 _1bsb1ego _1pbycs5v _14b5hc79 _qilnk0mc _4ap3vuon _scbpglyw",
  oldBorder: "_t51zzgxb",
  newBorder: "_191wglyw _t51zglyw _p5clzgxb",
  newBorderFlyoutOpen: "_p5clglyw",
  flyoutOpen: "_qiln1gzg _4ap31bhr _scbp1cd0 _139f8iot _1tpvfnf5 _sylc1a5r _oyeijq3t",
  flyoutAnimateClosed: "_1e0cglyw _qiln1gzg _139f8iot _1tpvfnf5 _sylc1a5r _1uwsjq3t",
  flexContainer: "_4t3i1osq _1e0c1txw _2lx21bp4 _1bah1yb4",
  hiddenMobileAndDesktop: "_1e0cglyw",
  hiddenMobileOnly: "_1e0cglyw _dm2518uv",
  hiddenDesktopOnly: "_dm25glyw"
};
function SideNavInternal(_ref) {
  var children = _ref.children, defaultCollapsed = _ref.defaultCollapsed, _ref$defaultWidth = _ref.defaultWidth, defaultWidth = _ref$defaultWidth === void 0 ? 320 : _ref$defaultWidth, testId = _ref.testId, _ref$label = _ref.label, label = _ref$label === void 0 ? "Sidebar" : _ref$label, _ref$skipLinkLabel = _ref.skipLinkLabel, skipLinkLabel = _ref$skipLinkLabel === void 0 ? label : _ref$skipLinkLabel, onExpand = _ref.onExpand, onCollapse = _ref.onCollapse, providedId = _ref.id;
  var id = useLayoutId({
    providedId
  });
  var expandSideNav = useExpandSideNav();
  var synchronouslyExpandSideNav = (0, import_react9.useCallback)(function() {
    (0, import_react_dom2.flushSync)(function() {
      expandSideNav();
    });
  }, [expandSideNav]);
  useSkipLinkInternal({
    id,
    label: skipLinkLabel,
    onBeforeNavigate: synchronouslyExpandSideNav
  });
  var sideNavState = (0, import_react9.useContext)(SideNavVisibilityState);
  var setSideNavState = (0, import_react9.useContext)(SetSideNavVisibilityState);
  var _useSideNavVisibility = useSideNavVisibility({
    defaultCollapsed
  }), isExpandedOnDesktop = _useSideNavVisibility.isExpandedOnDesktop, isExpandedOnMobile = _useSideNavVisibility.isExpandedOnMobile;
  var _useState = (0, import_react9.useState)(defaultCollapsed), _useState2 = _slicedToArray(_useState, 1), initialDefaultCollapsed = _useState2[0];
  var _useState3 = (0, import_react9.useState)(defaultWidth), _useState4 = _slicedToArray(_useState3, 2), width = _useState4[0], setWidth = _useState4[1];
  var clampedWidth = "clamp(".concat(widthResizeBounds.min, ", ").concat(width, "px, ").concat(widthResizeBounds.max, ")");
  var dangerouslyHoistSlotSizes = (0, import_react9.useContext)(DangerouslyHoistSlotSizes);
  var navRef = (0, import_react9.useRef)(null);
  var sharedRef = useSideNavRef();
  var mergedRef = mergeRefs([navRef, sharedRef]);
  var toggleButtonElement = (0, import_react9.useContext)(SideNavToggleButtonElement);
  var topNavStartElement = (0, import_react9.useContext)(TopNavStartElement);
  var devTimeOnlyAttributes = {};
  var openLayerObserver = useOpenLayerObserver();
  var flyoutStateRef = (0, import_react9.useRef)({
    type: "not-active"
  });
  var isFlyoutVisible = (sideNavState === null || sideNavState === void 0 ? void 0 : sideNavState.flyout) === "open";
  var updateFlyoutState = (0, import_react9.useMemo)(function() {
    function tryAbortPendingClose() {
      if (flyoutStateRef.current.type === "waiting-for-close") {
        flyoutStateRef.current.abort();
      }
    }
    function open() {
      tryAbortPendingClose();
      flyoutStateRef.current = {
        type: "open"
      };
      setSideNavState(function(currentState) {
        if ((currentState === null || currentState === void 0 ? void 0 : currentState.desktop) === "collapsed" && (currentState === null || currentState === void 0 ? void 0 : currentState.flyout) !== "open") {
          return {
            desktop: currentState.desktop,
            mobile: currentState.mobile,
            flyout: "open"
          };
        }
        return currentState;
      });
    }
    function close() {
      tryAbortPendingClose();
      flyoutStateRef.current = {
        type: "not-active"
      };
      setSideNavState(function(currentState) {
        if ((currentState === null || currentState === void 0 ? void 0 : currentState.desktop) === "collapsed" && (currentState === null || currentState === void 0 ? void 0 : currentState.flyout) === "open") {
          return {
            desktop: currentState.desktop,
            mobile: currentState.mobile,
            flyout: "triggered-animate-close"
          };
        }
        return currentState;
      });
    }
    return function onAction(action) {
      if (action === "drag-from-flyout-started") {
        open();
        flyoutStateRef.current = {
          type: "is-dragging-from-flyout"
        };
        return;
      }
      if (action === "drag-from-flyout-finished") {
        open();
        return;
      }
      if (flyoutStateRef.current.type === "is-dragging-from-flyout") {
        return;
      }
      if (action === "open") {
        open();
        return;
      }
      if (action === "waiting-for-close") {
        if (flyoutStateRef.current.type === "waiting-for-close") {
          return;
        }
        var timeout = setTimeout(function() {
          updateFlyoutState("ready-to-close");
        }, sideNavFlyoutCloseDelayMs);
        flyoutStateRef.current = {
          type: "waiting-for-close",
          abort: function abort() {
            clearTimeout(timeout);
          }
        };
        return;
      }
      if (action === "ready-to-close") {
        if (openLayerObserver.getCount({
          namespace: openLayerObserverSideNavNamespace
        }) === 0) {
          close();
          return;
        }
        flyoutStateRef.current = {
          type: "ready-to-close"
        };
        return;
      }
      if (action === "force-close") {
        close();
        return;
      }
    };
  }, [openLayerObserver, setSideNavState]);
  var toggleVisibility = useToggleSideNav();
  (0, import_react9.useEffect)(function() {
    setSideNavState({
      desktop: initialDefaultCollapsed ? "collapsed" : "expanded",
      mobile: "collapsed",
      flyout: "closed"
    });
  }, [initialDefaultCollapsed, setSideNavState]);
  var handleExpand = (0, import_react9.useCallback)(function(_ref2) {
    var screen = _ref2.screen;
    onExpand === null || onExpand === void 0 || onExpand({
      screen
    });
    updateFlyoutState("force-close");
  }, [onExpand, updateFlyoutState]);
  var handleCollapse = (0, import_react9.useCallback)(function(_ref3) {
    var screen = _ref3.screen;
    onCollapse === null || onCollapse === void 0 || onCollapse({
      screen
    });
    updateFlyoutState("force-close");
  }, [onCollapse, updateFlyoutState]);
  useSideNavVisibilityCallbacks({
    onExpand: handleExpand,
    onCollapse: handleCollapse,
    isExpandedOnDesktop,
    isExpandedOnMobile
  });
  (0, import_react9.useEffect)(function() {
    var mediaQueryList = window.matchMedia("(min-width: 64rem)");
    return (0, import_bind_event_listener7.bind)(mediaQueryList, {
      type: "change",
      listener: function listener() {
        if (mediaQueryList.matches) {
          if (isExpandedOnMobile && !isExpandedOnDesktop) {
            toggleVisibility();
          }
        }
      }
    });
  }, [toggleVisibility, isExpandedOnDesktop, isExpandedOnMobile]);
  (0, import_react9.useEffect)(function() {
    if (!isExpandedOnMobile) {
      return;
    }
    var skipLinkUrlFragment = "#".concat(id);
    return (0, import_bind_event_listener7.bind)(window, {
      type: "click",
      listener: function listener(event) {
        if (window.matchMedia("(min-width: 64rem)").matches) {
          return;
        }
        var sideNav = navRef.current;
        if (!sideNav || !(event.target instanceof Node)) {
          return;
        }
        if (sideNav.contains(event.target)) {
          return;
        }
        if (toggleButtonElement !== null && toggleButtonElement !== void 0 && toggleButtonElement.contains(event.target)) {
          return;
        }
        if (event.target instanceof HTMLAnchorElement && /**
         * Intentionally using `.getAttribute()` for simplicity to match exactly what we expect
         * for skip links.
         *
         * Alternatives considered:
         *
         * - Using `.href` returns a full URL, which would then require extra parsing.
         * - Using `.hash` could incorrectly capture `<a href="/another-page#skip-link-id>` so we'd need extra checks.
         *
         * This approach has an edge case of `<a href="/same-page#skip-link-id>` not being captured,
         * but we are okay with that trade-off.
         */
        event.target.getAttribute("href") === skipLinkUrlFragment) {
          return;
        }
        toggleVisibility();
      }
    });
  }, [id, isExpandedOnMobile, toggleButtonElement, toggleVisibility]);
  (0, import_react9.useEffect)(function() {
    if (!toggleButtonElement) {
      return;
    }
    return (0, import_bind_event_listener7.bind)(toggleButtonElement, {
      type: "mouseenter",
      listener: function listener() {
        if (isExpandedOnDesktop) {
          return;
        }
        var _window$matchMedia = window.matchMedia("(min-width: 64rem)"), matches = _window$matchMedia.matches;
        if (matches) {
          updateFlyoutState("open");
        }
      }
    });
  }, [updateFlyoutState, toggleButtonElement, isExpandedOnDesktop]);
  (0, import_react9.useEffect)(function() {
    if (!toggleButtonElement) {
      return;
    }
    return (0, import_bind_event_listener7.bind)(toggleButtonElement, {
      type: "mouseleave",
      listener: function listener() {
        if (!isFlyoutVisible) {
          return;
        }
        updateFlyoutState("waiting-for-close");
      }
    });
  }, [isFlyoutVisible, toggleButtonElement, updateFlyoutState]);
  (0, import_react9.useEffect)(function() {
    if (!navRef.current) {
      return;
    }
    return (0, import_bind_event_listener7.bind)(navRef.current, {
      type: "mouseenter",
      listener: function listener() {
        if (isExpandedOnDesktop || !isFlyoutVisible) {
          return;
        }
        updateFlyoutState("open");
      }
    });
  }, [isFlyoutVisible, updateFlyoutState, isExpandedOnDesktop]);
  (0, import_react9.useEffect)(function() {
    if (!navRef.current) {
      return;
    }
    return (0, import_bind_event_listener7.bind)(navRef.current, {
      type: "mouseleave",
      listener: function listener() {
        if (!isFlyoutVisible) {
          return;
        }
        updateFlyoutState("waiting-for-close");
      }
    });
  }, [isFlyoutVisible, updateFlyoutState]);
  (0, import_react9.useEffect)(function() {
    var nav = navRef.current;
    if (!nav) {
      return;
    }
    if (!isFlyoutVisible) {
      return;
    }
    return monitorForElements({
      canMonitor: function canMonitor(_ref4) {
        var source = _ref4.source;
        return nav.contains(source.element);
      },
      onGenerateDragPreview: function onGenerateDragPreview() {
        updateFlyoutState("drag-from-flyout-started");
      },
      onDrop: function onDrop(_ref5) {
        var location = _ref5.location;
        updateFlyoutState("drag-from-flyout-finished");
        var underUsersPointer = document.elementFromPoint(location.current.input.clientX, location.current.input.clientY);
        if (!nav.contains(underUsersPointer)) {
          updateFlyoutState("waiting-for-close");
        }
      }
    });
  }, [isFlyoutVisible, updateFlyoutState]);
  (0, import_react9.useEffect)(function() {
    if (!topNavStartElement || !toggleButtonElement) {
      return;
    }
    return (0, import_bind_event_listener7.bind)(topNavStartElement, {
      type: "mouseover",
      listener: function listener(event) {
        if (isExpandedOnDesktop || !isFlyoutVisible) {
          return;
        }
        if (event.target === topNavStartElement) {
          updateFlyoutState("open");
          return;
        }
        if (event.target instanceof Element && toggleButtonElement.contains(event.target)) {
          return;
        }
        updateFlyoutState("waiting-for-close");
      }
    });
  }, [topNavStartElement, isFlyoutVisible, toggleButtonElement, isExpandedOnDesktop, updateFlyoutState]);
  (0, import_react9.useEffect)(function() {
    if (!topNavStartElement) {
      return;
    }
    return (0, import_bind_event_listener7.bind)(topNavStartElement, {
      type: "mouseleave",
      listener: function listener() {
        if (!isFlyoutVisible) {
          return;
        }
        updateFlyoutState("waiting-for-close");
      }
    });
  }, [topNavStartElement, isFlyoutVisible, updateFlyoutState]);
  (0, import_react9.useEffect)(function() {
    return openLayerObserver.onChange(function(_ref6) {
      var count = _ref6.count;
      if (flyoutStateRef.current.type === "ready-to-close" && count === 0) {
        updateFlyoutState("force-close");
      }
    }, {
      namespace: openLayerObserverSideNavNamespace
    });
  }, [openLayerObserver, updateFlyoutState]);
  (0, import_react9.useEffect)(function() {
    return function cleanupPendingFlyoutClose() {
      if (flyoutStateRef.current.type === "waiting-for-close") {
        flyoutStateRef.current.abort();
      }
    };
  }, []);
  if (true) {
    var visible = [];
    if (isExpandedOnMobile) {
      visible.push("small");
    }
    if (isExpandedOnDesktop) {
      visible.push("large");
    }
    if (isFlyoutVisible) {
      visible.push("flyout");
    }
    devTimeOnlyAttributes["data-visible"] = visible.length ? visible.join(",") : "false";
  }
  useResizingWidthCssVarOnRootElement({
    isEnabled: true,
    cssVar: panelSplitterResizingVar,
    panelId: sideNavPanelSplitterId
  });
  return React3.createElement(
    "nav",
    _extends({
      id
    }, devTimeOnlyAttributes, {
      "data-layout-slot": true,
      "aria-label": label,
      style: _defineProperty({}, sideNavVar, clampedWidth),
      ref: mergedRef,
      "data-testid": testId,
      className: ax([styles.root, fg("platform_design_system_nav4_sidenav_border") ? styles.newBorder : styles.oldBorder, isExpandedOnDesktop && !isExpandedOnMobile && !isFlyoutVisible && styles.hiddenMobileOnly, !isExpandedOnDesktop && isExpandedOnMobile && !isFlyoutVisible && styles.hiddenDesktopOnly, !isExpandedOnDesktop && !isExpandedOnMobile && !isFlyoutVisible && styles.hiddenMobileAndDesktop, (sideNavState === null || sideNavState === void 0 ? void 0 : sideNavState.flyout) === "open" && styles.flyoutOpen, (sideNavState === null || sideNavState === void 0 ? void 0 : sideNavState.flyout) === "open" && fg("platform_design_system_nav4_sidenav_border") && styles.newBorderFlyoutOpen, (sideNavState === null || sideNavState === void 0 ? void 0 : sideNavState.flyout) === "triggered-animate-close" && styles.flyoutAnimateClosed])
    }),
    React3.createElement(DangerouslyHoistCssVarToDocumentRoot, {
      variableName: sideNavLiveWidthVar,
      value: "0px",
      mediaQuery: media.above.md,
      responsiveValue: isExpandedOnDesktop ? "var(".concat(panelSplitterResizingVar, ", ").concat(clampedWidth, ")") : 0
    }),
    dangerouslyHoistSlotSizes && // ------ START UNSAFE STYLES ------
    // These styles are only needed for the UNSAFE legacy use case for Jira + Confluence.
    // When they aren't needed anymore we can delete them wholesale.
    React3.createElement(DangerouslyHoistCssVarToDocumentRoot, {
      variableName: UNSAFE_sideNavLayoutVar,
      value: "var(".concat(sideNavLiveWidthVar, ")")
    }),
    React3.createElement(PanelSplitterProvider, {
      panelId: sideNavPanelSplitterId,
      panelRef: navRef,
      panelWidth: width,
      onCompleteResize: setWidth,
      getResizeBounds,
      resizingCssVar: panelSplitterResizingVar,
      isEnabled: isExpandedOnDesktop && !isFlyoutVisible
    }, React3.createElement("div", {
      className: ax([styles.flexContainer])
    }, children))
  );
}
function SideNav(_ref8) {
  var children = _ref8.children, defaultCollapsed = _ref8.defaultCollapsed, _ref8$defaultWidth = _ref8.defaultWidth, defaultWidth = _ref8$defaultWidth === void 0 ? 320 : _ref8$defaultWidth, testId = _ref8.testId, label = _ref8.label, _ref8$skipLinkLabel = _ref8.skipLinkLabel, skipLinkLabel = _ref8$skipLinkLabel === void 0 ? label : _ref8$skipLinkLabel, onExpand = _ref8.onExpand, onCollapse = _ref8.onCollapse, id = _ref8.id;
  return React3.createElement(OpenLayerObserverNamespaceProvider, {
    namespace: openLayerObserverSideNavNamespace
  }, React3.createElement(SideNavInternal, {
    defaultCollapsed,
    defaultWidth,
    testId,
    label,
    skipLinkLabel,
    onExpand,
    onCollapse,
    id
  }, children));
}

// node_modules/@atlaskit/navigation-system/dist/esm/ui/page-layout/side-nav/side-nav-header.js
var React4 = __toESM(require_react());
init_runtime();
import "/Users/movalle/Documents/GitHub/test-enhanced-app/node_modules/@atlaskit/navigation-system/dist/esm/ui/page-layout/side-nav/side-nav-header.compiled.css";
var styles2 = {
  root: "_18zrutpp _1q51utpp _85i51b66"
};
var SideNavHeader = function SideNavHeader2(_ref) {
  var children = _ref.children;
  return React4.createElement("div", {
    className: ax([styles2.root])
  }, children);
};

// node_modules/@atlaskit/navigation-system/dist/esm/ui/page-layout/side-nav/side-nav-content.js
var React5 = __toESM(require_react());
init_runtime();
var import_react10 = __toESM(require_react());
import "/Users/movalle/Documents/GitHub/test-enhanced-app/node_modules/@atlaskit/navigation-system/dist/esm/ui/page-layout/side-nav/side-nav-content.compiled.css";
var SideNavContent = (0, import_react10.forwardRef)(_SideNavContent);
var styles3 = {
  scrollContainer: "_16jlkb7n _1o9zkb7n _i0dlf1ug _1reo1wug _18m91wug",
  paddingContainer: "_ca0qutpp _u5f3utpp _n3tdutpp _19bvutpp"
};
function _SideNavContent(_ref, ref) {
  var children = _ref.children, testId = _ref.testId;
  return React5.createElement("div", {
    ref,
    "data-testid": testId,
    className: ax([styles3.scrollContainer])
  }, React5.createElement("div", {
    className: ax([styles3.paddingContainer])
  }, children));
}

// node_modules/@atlaskit/navigation-system/dist/esm/ui/page-layout/side-nav/side-nav-footer.js
var React6 = __toESM(require_react());
init_runtime();
import "/Users/movalle/Documents/GitHub/test-enhanced-app/node_modules/@atlaskit/navigation-system/dist/esm/ui/page-layout/side-nav/side-nav-footer.compiled.css";
var styles4 = {
  root: "_ca0qutpp _u5f3utpp _n3tdutpp _19bvutpp _7myae4h9 _1sw7nqa1 _qgnumuej"
};
var SideNavFooter = function SideNavFooter2(_ref) {
  var children = _ref.children, xcss = _ref.xcss;
  return React6.createElement("div", {
    className: ax([styles4.root, xcss])
  }, children);
};

// node_modules/@atlaskit/navigation-system/dist/esm/ui/page-layout/side-nav/toggle-button.js
init_slicedToArray();
init_runtime();
var import_react11 = __toESM(require_react());
var import_bind_event_listener8 = __toESM(require_dist());
var import_sidebar_collapse = __toESM(require_sidebar_collapse());
var import_sidebar_expand = __toESM(require_sidebar_expand());
init_esm();
import "/Users/movalle/Documents/GitHub/test-enhanced-app/node_modules/@atlaskit/navigation-system/dist/esm/ui/page-layout/side-nav/toggle-button.compiled.css";
var toggleButtonTooltipOptions = {
  // We're disabling pointer events on the tooltip to prevent it from blocking mouse events, so that the side nav flyout stays open
  // when moving the mouse from the top bar to the side nav.
  ignoreTooltipPointerEvents: true
};
var SideNavToggleButton = function SideNavToggleButton2(_ref) {
  var _ref$defaultCollapsed = _ref.defaultCollapsed, defaultCollapsed = _ref$defaultCollapsed === void 0 ? false : _ref$defaultCollapsed, expandLabel = _ref.expandLabel, collapseLabel = _ref.collapseLabel, testId = _ref.testId, interactionName = _ref.interactionName, onClick = _ref.onClick;
  var _useSideNavVisibility = useSideNavVisibility({
    defaultCollapsed
  }), isSideNavExpandedOnDesktop = _useSideNavVisibility.isExpandedOnDesktop, isSideNavExpandedOnMobile = _useSideNavVisibility.isExpandedOnMobile;
  var _useState = (0, import_react11.useState)(!defaultCollapsed), _useState2 = _slicedToArray(_useState, 2), isSideNavExpanded = _useState2[0], setIsSideNavExpanded = _useState2[1];
  var ref = (0, import_react11.useContext)(SideNavToggleButtonAttachRef);
  var elementRef = (0, import_react11.useRef)(null);
  (0, import_react11.useEffect)(function() {
    if (fg("platform_fix_component_state_update_for_suspense")) {
      ref(elementRef.current);
    }
  }, [elementRef, ref]);
  (0, import_react11.useEffect)(function() {
    var _window$matchMedia = window.matchMedia("(min-width: 64rem)"), matches = _window$matchMedia.matches;
    setIsSideNavExpanded(matches ? isSideNavExpandedOnDesktop : isSideNavExpandedOnMobile);
  }, [isSideNavExpandedOnDesktop, isSideNavExpandedOnMobile]);
  (0, import_react11.useEffect)(function() {
    var mediaQueryList = window.matchMedia("(min-width: 64rem)");
    return (0, import_bind_event_listener8.bind)(mediaQueryList, {
      type: "change",
      listener: function listener() {
        setIsSideNavExpanded(mediaQueryList.matches ? isSideNavExpandedOnDesktop : isSideNavExpandedOnMobile);
      }
    });
  }, [isSideNavExpandedOnDesktop, isSideNavExpandedOnMobile]);
  var toggleVisibility = useToggleSideNav();
  var handleClick = (0, import_react11.useCallback)(function(event, analyticsEvent) {
    onClick === null || onClick === void 0 || onClick(event, analyticsEvent, {
      isSideNavVisible: isSideNavExpanded
    });
    toggleVisibility();
  }, [onClick, toggleVisibility, isSideNavExpanded]);
  var icon = function icon2(props) {
    return import_react11.default.createElement("span", {
      className: ax(["_1e0c1bgi _lcxvglyw"])
    }, isSideNavExpanded ? import_react11.default.createElement(import_sidebar_collapse.default, props) : import_react11.default.createElement(import_sidebar_expand.default, props));
  };
  return import_react11.default.createElement(IconButton, {
    appearance: "subtle",
    label: isSideNavExpanded ? collapseLabel : expandLabel,
    icon,
    onClick: handleClick,
    testId,
    isTooltipDisabled: false,
    interactionName,
    ref: fg("platform_fix_component_state_update_for_suspense") ? elementRef : ref,
    tooltip: toggleButtonTooltipOptions
  });
};

export {
  PanelSplitterProvider,
  PanelSplitter,
  useResizingWidthCssVarOnRootElement,
  useExpandSideNav,
  useToggleSideNav,
  SideNav,
  SideNavHeader,
  SideNavContent,
  SideNavFooter,
  SideNavToggleButton
};
//# sourceMappingURL=chunk-FGFAXZ6F.js.map

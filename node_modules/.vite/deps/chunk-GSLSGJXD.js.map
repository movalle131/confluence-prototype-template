{
  "version": 3,
  "sources": ["../../@atlaskit/layering/dist/esm/components/open-layer-observer/open-layer-observer.js", "../../@atlaskit/layering/dist/esm/components/open-layer-observer/open-layer-observer-context.js", "../../@atlaskit/layering/dist/esm/components/open-layer-observer/use-open-layer-observer.js", "../../@atlaskit/layering/dist/esm/components/open-layer-observer/open-layer-observer-namespace-provider.js", "../../@atlaskit/layering/dist/esm/components/open-layer-observer/open-layer-observer-namespace-context.js", "../../@atlaskit/layering/dist/esm/components/open-layer-observer/use-open-layer-observer-namespace.js", "../../@atlaskit/layering/dist/esm/components/open-layer-observer/use-notify-open-layer-observer.js"],
  "sourcesContent": ["import _slicedToArray from \"@babel/runtime/helpers/slicedToArray\";\nimport React, { useContext, useState } from 'react';\nimport invariant from 'tiny-invariant';\nimport { OpenLayerObserverContext } from './open-layer-observer-context';\n/**\n * Layers that are registered without a namespace are grouped under this fallback namespace.\n */\nvar noNamespaceSymbol = Symbol('no-namespace');\n/**\n * Returns the number of open layers across all namespaces.\n * It calculates the sum of the set sizes in the map, which corresponds to the number of open layers.\n */\nfunction getTotalOpenLayerCount(registry) {\n  return Array.from(registry.values()).reduce(function (acc, listeners) {\n    return acc + listeners.size;\n  }, 0);\n}\n\n/**\n * Returns the layer count change listeners set for the namespace.\n * If there are no listeners registered for the namespace yet, it creates a new set\n * and adds it to the registry, then returns the new set.\n */\nfunction getListeners(_ref) {\n  var registry = _ref.registry,\n    namespace = _ref.namespace;\n  // 1. If there are existing listeners for this namespace, return the existing set.\n  var existingListeners = registry.get(namespace);\n  if (existingListeners) {\n    return existingListeners;\n  }\n\n  // 2. If there are no existing listeners for this namespace, create a new set for this namespace\n  // and add it to the registry, then return the new set.\n  var newSet = new Set();\n  registry.set(namespace, newSet);\n  return newSet;\n}\n\n/**\n * Returns an instance of the open layer observer API. It internally keeps track of the number of open layers and\n * exposes methods to get the current count, increment/decrement the count, and subscribe to changes.\n */\nfunction createInternalAPI() {\n  /**\n   * The layer count change listeners for each namespace.\n   */\n  var namespaceToChangeListenerRegistry = new Map();\n\n  /**\n   * The `onClose` listeners for each namespace.\n   * Each layer provides an `onClose` callback. **When the layer is open**, its `onClose`\n   * callback is registered in this set.\n   *\n   * This data structure is also used determine the number of open layers.\n   */\n  var namespaceToLayerCloseListenerRegistry = new Map();\n\n  /**\n   * Calls the appropriate layer count change listeners after the number of open layers has changed.\n   */\n  function callChangeListeners(_ref2) {\n    var namespace = _ref2.namespace,\n      newCount = _ref2.newCount;\n    // 1. Call listeners registered to the specific namespace\n    if (namespace) {\n      var listenersForNamespace = namespaceToChangeListenerRegistry.get(namespace);\n\n      // Using `Array.from` to ensure we iterate over a stable list - e.g. in case a listener adds to the registry while we are\n      // iterating over it.\n      Array.from(listenersForNamespace !== null && listenersForNamespace !== void 0 ? listenersForNamespace : []).forEach(function (listener) {\n        return listener({\n          count: newCount\n        });\n      });\n    }\n\n    // 2. Call listeners registered without a specific namespace\n    var noNamespaceListeners = namespaceToChangeListenerRegistry.get(noNamespaceSymbol);\n\n    // Return early if no listeners\n    if (!noNamespaceListeners) {\n      return;\n    }\n\n    // For the listeners without a specific namespace, we need to provide the sum of all namespace counts\n    // as the callback `count` arg.\n    var totalCount = getTotalOpenLayerCount(namespaceToLayerCloseListenerRegistry);\n    Array.from(noNamespaceListeners).forEach(function (listener) {\n      return listener({\n        count: totalCount\n      });\n    });\n  }\n\n  /**\n   * Returns the current count of open layers.\n   *\n   * If a namespace is provided, the count for that namespace is returned.\n   * Otherwise, the sum of all namespace counts is returned.\n   */\n  function getCount() {\n    var _ref3 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n      namespace = _ref3.namespace;\n    if (namespace) {\n      var _namespaceToLayerClos, _namespaceToLayerClos2;\n      return (_namespaceToLayerClos = (_namespaceToLayerClos2 = namespaceToLayerCloseListenerRegistry.get(namespace)) === null || _namespaceToLayerClos2 === void 0 ? void 0 : _namespaceToLayerClos2.size) !== null && _namespaceToLayerClos !== void 0 ? _namespaceToLayerClos : 0;\n    }\n\n    // A specific namespace was not requested, so we return the sum across all namespaces.\n    return getTotalOpenLayerCount(namespaceToLayerCloseListenerRegistry);\n  }\n\n  /**\n   * Adds a listener that will be called when the number of open layers changes.\n   *\n   * @returns a cleanup function to unsubscribe, which should be called when the component unmounts.\n   */\n  function onChange(listener) {\n    var _ref4 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n      providedNamespace = _ref4.namespace;\n    /**\n     * We are wrapping the passed listener in a function to ensure that each call to `onChange` creates a unique\n     * function reference. This is to handle scenarios where the same function is provided to several different `onChange`\n     * calls - we want to ensure that each call to `unsubscribe` only removes the specific listener registration that was added.\n     */\n    function wrapped() {\n      listener.apply(void 0, arguments);\n    }\n    var namespace = providedNamespace !== null && providedNamespace !== void 0 ? providedNamespace : noNamespaceSymbol;\n    var listenersForNamespace = getListeners({\n      namespace: namespace,\n      registry: namespaceToChangeListenerRegistry\n    });\n    listenersForNamespace.add(wrapped);\n    return function unsubscribe() {\n      listenersForNamespace.delete(wrapped);\n\n      // If there are no listeners for this namespace, remove the registry entry.\n      if (listenersForNamespace.size === 0) {\n        namespaceToChangeListenerRegistry.delete(namespace);\n      }\n    };\n  }\n\n  /**\n   * Adds a listener to the registry that tells the observer how to close the layer component.\n   * The listener should only be added if the layer is open. This is handled by `useNotifyOpenLayerObserver`.\n   *\n   * All close listeners will be called by the observer when `closeLayers` is called.\n   *\n   * @returns a cleanup function to unsubscribe, which should be called when the component unmounts.\n   */\n  function onClose(listener, _ref5) {\n    var providedNamespace = _ref5.namespace;\n    /**\n     * We are wrapping the passed listener in a function to ensure that each call to `onClose` creates a unique\n     * function reference. This is to handle scenarios where the same function is provided to several different `onClose`\n     * calls - we want to ensure that each call to `unsubscribe` only removes the specific listener registration that was added.\n     */\n    function wrapped() {\n      listener();\n    }\n    var namespace = providedNamespace !== null && providedNamespace !== void 0 ? providedNamespace : noNamespaceSymbol;\n    var listenersForNamespace = getListeners({\n      namespace: namespace,\n      registry: namespaceToLayerCloseListenerRegistry\n    });\n    listenersForNamespace.add(wrapped);\n    callChangeListeners({\n      namespace: providedNamespace,\n      newCount: listenersForNamespace.size\n    });\n    return function unsubscribe() {\n      listenersForNamespace.delete(wrapped);\n      callChangeListeners({\n        namespace: providedNamespace,\n        newCount: listenersForNamespace.size\n      });\n\n      // If there are no listeners for this namespace, remove the registry entry.\n      if (listenersForNamespace.size === 0) {\n        namespaceToLayerCloseListenerRegistry.delete(namespace);\n      }\n    };\n  }\n\n  /**\n   * Closes all open layers registered across all namespaces.\n   */\n  function closeLayers() {\n    // Using `Array.from` to ensure we iterate over a stable list - e.g. in case a listener adds to the registry while we are\n    // iterating over it.\n    Array.from(namespaceToLayerCloseListenerRegistry.values()).forEach(function (listeners) {\n      Array.from(listeners).forEach(function (listener) {\n        return listener();\n      });\n    });\n  }\n  var internalAPI = {\n    getCount: getCount,\n    onChange: onChange,\n    onClose: onClose,\n    closeLayers: closeLayers\n  };\n  return internalAPI;\n}\n\n/**\n * Context provider for observing the number of __open__ layering components (e.g. popups, dropdown menus) under the observer.\n * It uses a stable object to keep track of the number of open layered components - which means the observer will not re-render\n * when the number of layers changes.\n *\n * There should only be one `OpenLayerObserver` in the application. If there are more, the component will throw an error.\n * To track the number of layers in a section of the application, use the `OpenLayerObserverNamespaceProvider` to create a new\n * namespace to group layers.\n *\n * It is intended for use with the `useOpenLayerObserver` hook.\n */\nexport function OpenLayerObserver(_ref6) {\n  var children = _ref6.children;\n  // Using state to ensure a stable reference to a single instance.\n  var _useState = useState(function () {\n      return createInternalAPI();\n    }),\n    _useState2 = _slicedToArray(_useState, 1),\n    internalAPI = _useState2[0];\n  var parentContext = useContext(OpenLayerObserverContext);\n\n  // We don't expect a parent context. If there is one, that means this component is nested within another `OpenLayerObserver`\n  // - which we don't support.\n  invariant(parentContext === null, '`OpenLayerObserver` cannot be nested within another `OpenLayerObserver`.');\n  return /*#__PURE__*/React.createElement(OpenLayerObserverContext.Provider, {\n    value: internalAPI\n  }, children);\n}", "import { createContext } from 'react';\n/**\n * Context for the open layer observer.\n *\n * We are setting the default value to `null` so we can check if there are nested context providers,\n * so we know to update the layer count in the parent context as well.\n */\nexport var OpenLayerObserverContext = /*#__PURE__*/createContext(null);", "import { useContext, useMemo } from 'react';\nimport invariant from 'tiny-invariant';\nimport { OpenLayerObserverContext } from './open-layer-observer-context';\n/**\n * A hook for use within an `OpenLayerObserver` component. It provides access to:\n *\n * - `getCount`: a function that returns the current count of open layers under the observer.\n * - `onChange`: a function that allows you to subscribe to changes in the layer count. It returns a\n * cleanup function to unsubscribe, which you should call when the component unmounts.\n * - `closeLayers`: a function that closes all open layers.\n *\n * Example usage:\n * ```tsx\n * const openLayerObserver = useOpenLayerObserver();\n * useEffect(() => {\n *   return openLayerObserver.onChange(function onChange({ count }) {\n *     // react to changes in the layer count\n *   });\n * }, [openLayerObserver]);\n * ```\n */\nexport function useOpenLayerObserver() {\n  var context = useContext(OpenLayerObserverContext);\n  invariant(context, 'useOpenLayerObserver must be used within an OpenLayerObserver');\n  var publicAPI = useMemo(function () {\n    return {\n      getCount: context.getCount,\n      onChange: context.onChange,\n      closeLayers: context.closeLayers\n    };\n  }, [context.getCount, context.onChange, context.closeLayers]);\n  return publicAPI;\n}", "import React, { useEffect } from 'react';\nimport invariant from 'tiny-invariant';\nimport { OpenLayerObserverNamespaceContext } from './open-layer-observer-namespace-context';\nimport { useOpenLayerObserverNamespace } from './use-open-layer-observer-namespace';\n\n/**\n * Creates a layer namespace for grouping layers together.\n */\nexport function OpenLayerObserverNamespaceProvider(_ref) {\n  var children = _ref.children,\n    namespace = _ref.namespace;\n  // If there is an existing namespace context being provided, throw an invariant.\n  // This use case is not supported at this time.\n  var parentContext = useOpenLayerObserverNamespace();\n  useEffect(function () {\n    invariant(parentContext === null, \"An OpenLayerObserver namespace already exists in this component tree: \".concat(parentContext, \". Nesting OpenLayerObserverNamespaceProvider is not supported.\"));\n  }, [parentContext]);\n  return /*#__PURE__*/React.createElement(OpenLayerObserverNamespaceContext.Provider, {\n    value: namespace\n  }, children);\n}", "import { createContext } from 'react';\n\n/**\n * A context for creating a namespace for grouping layers.\n *\n * This is useful for determining the number of layers open within a section of the page, e.g. the SideNav.\n */\nexport var OpenLayerObserverNamespaceContext = /*#__PURE__*/createContext(null);", "import { useContext } from 'react';\nimport { OpenLayerObserverNamespaceContext } from './open-layer-observer-namespace-context';\n\n/**\n * A hook for use within an `OpenLayerObserver` component. It provides access to the namespace of the\n * `OpenLayerObserver`.\n *\n * This is useful for determining the number of layers open within a section of the page, e.g. the SideNav.\n */\nexport function useOpenLayerObserverNamespace() {\n  var namespace = useContext(OpenLayerObserverNamespaceContext);\n  return namespace;\n}", "import { useContext, useEffect } from 'react';\nimport { OpenLayerObserverContext } from './open-layer-observer-context';\nimport { useOpenLayerObserverNamespace } from './use-open-layer-observer-namespace';\n/**\n * Hook that increments/decrements the open layer count when the component mounts/unmounts or becomes visible/hidden.\n * It is used to \"notify\" the layer observer(s) that a new layer has been added/opened.\n *\n * It takes an object with two arguments:\n * - `isOpen` - used to conditionally update the layer count based on the visibility of the layered component.\n * - `onClose` - callback used to close this layer when the OpenLayerObserver has called `closeLayers`.\n *\n * Example usage:\n * ```tsx\n * const [isOpen, setIsOpen] = useState(false); // State for controlling layer visibility\n * useNotifyLayerObserver({\n *   isOpen,\n *   onClose: () => setIsOpen(false) // Optional callback to close this layer\n * });\n * ```\n */\nexport function useNotifyOpenLayerObserver(_ref) {\n  var isOpen = _ref.isOpen,\n    onClose = _ref.onClose;\n  var context = useContext(OpenLayerObserverContext);\n  var namespace = useOpenLayerObserverNamespace();\n  useEffect(function () {\n    /**\n     * Registers the `onClose` callback with the OpenLayerObserver.\n     */\n\n    if (context === null) {\n      return;\n    }\n    if (!isOpen) {\n      /**\n       * If the layer is not open, we are not registering the `onClose` callback.\n       * This is important to prevent the `onClose` from being called for layers that\n       * are not open.\n       *\n       * Some consumers mistakenly pass \"toggle\" functions to `onClose` callbacks for\n       * layer components, as Popup, e.g. `onClose={() => setIsOpen(!isOpen)}`.\n       */\n      return;\n    }\n    return context.onClose(onClose, {\n      namespace: namespace\n    });\n  }, [context, isOpen, namespace, onClose]);\n}"],
  "mappings": "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",
  "names": ["import_react", "React", "import_react", "import_react", "import_react", "import_react", "React", "import_react"]
}
